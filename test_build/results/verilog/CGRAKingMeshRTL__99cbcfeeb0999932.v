//-------------------------------------------------------------------------
// CGRAKingMeshRTL__99cbcfeeb0999932.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL BitStruct CGRAConfig_6_4_8_8 Definition
// At BitStruct CGRAConfig_6_4_8_8
typedef struct packed {
  logic [5:0] ctrl ;
  logic [0:0] predicate ;
  logic [3:0][2:0] fu_in ;
  logic [7:0][3:0] outport ;
  logic [7:0][0:0] predicate_in ;
} CGRAConfig_6_4_8_8;

// PyMTL BitStruct CGRAData_32_1_1 Definition
// At BitStruct CGRAData_32_1_1
typedef struct packed {
  logic [31:0] payload ;
  logic [0:0] predicate ;
  logic [0:0] bypass ;
} CGRAData_32_1_1;

// PyMTL BitStruct CGRAData_1_1 Definition
// At BitStruct CGRAData_1_1
typedef struct packed {
  logic [0:0] payload ;
  logic [0:0] predicate ;
} CGRAData_1_1;

// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_CGRAData_32_1_1__nregs_8__rd_ports_2__wr_ports_4__const_zero_False
// At /home/rms/mambaforge/envs/pycgra/lib/python3.7/site-packages/pymtl3/stdlib/rtl/RegisterFile.py

module RegisterFile__b9e413d457c37299
(
  input logic [0:0] clk,
  input logic [2:0] raddr [0:1],
  output CGRAData_32_1_1 rdata [0:1],
  input logic [0:0] reset,
  input logic [2:0] waddr [0:3],
  input CGRAData_32_1_1 wdata [0:3],
  input logic [0:0] wen [0:3]
);
  localparam logic [31:0] __const__rd_ports_at_up_rf_read = 32'd2;
  localparam logic [31:0] __const__wr_ports_at_up_rf_write = 32'd4;
  CGRAData_32_1_1 regs [0:7] ;

  // PyMTL Update Block Source
  // At /home/rms/mambaforge/envs/pycgra/lib/python3.7/site-packages/pymtl3/stdlib/rtl/RegisterFile.py:20
  // @s.update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] = s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int i = 0; i < __const__rd_ports_at_up_rf_read; i += 1 )
      rdata[i] = regs[raddr[i]];
  end

  // PyMTL Update Block Source
  // At /home/rms/mambaforge/envs/pycgra/lib/python3.7/site-packages/pymtl3/stdlib/rtl/RegisterFile.py:32
  // @s.update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int i = 0; i < __const__wr_ports_at_up_rf_write; i += 1 )
      if ( wen[i] ) begin
        regs[waddr[i]] <= wdata[i];
      end
  end

endmodule


// PyMTL Component DataMemRTL Definition
// Full name: DataMemRTL__DataType_CGRAData_32_1_1__data_mem_size_8__rd_ports_2__wr_ports_2__preload_data_None
// At ../../VectorCGRA/mem/data/DataMemRTL.py

module DataMemRTL__8bb42015d7ad3eea
(
  input logic [0:0] clk,
  input logic [0:0] reset,
  input logic [0:0] recv_raddr__en [0:1],
  input logic [2:0] recv_raddr__msg [0:1],
  output logic [0:0] recv_raddr__rdy [0:1],
  input logic [0:0] recv_waddr__en [0:1],
  input logic [2:0] recv_waddr__msg [0:1],
  output logic [0:0] recv_waddr__rdy [0:1],
  input logic [0:0] recv_wdata__en [0:1],
  input CGRAData_32_1_1 recv_wdata__msg [0:1],
  output logic [0:0] recv_wdata__rdy [0:1],
  output logic [0:0] send_rdata__en [0:1],
  output CGRAData_32_1_1 send_rdata__msg [0:1],
  input logic [0:0] send_rdata__rdy [0:1]
);
  localparam logic [31:0] __const__rd_ports_at_update_read_without_init = 32'd2;
  localparam logic [31:0] __const__wr_ports_at_update_read_without_init = 32'd2;
  localparam logic [31:0] __const__rd_ports_at_update_init = 32'd2;
  localparam logic [31:0] __const__wr_ports_at_update_init = 32'd2;
  localparam logic [31:0] __const__rd_ports_at_update_signal = 32'd2;
  localparam logic [31:0] __const__wr_ports_at_update_signal = 32'd2;
  logic [0:0] initWrites [0:7] ;
  //-------------------------------------------------------------
  // Component reg_file
  //-------------------------------------------------------------

  logic [0:0] reg_file__clk ;
  logic [2:0] reg_file__raddr [0:1] ;
  CGRAData_32_1_1 reg_file__rdata [0:1] ;
  logic [0:0] reg_file__reset ;
  logic [2:0] reg_file__waddr [0:3] ;
  CGRAData_32_1_1 reg_file__wdata [0:3] ;
  logic [0:0] reg_file__wen [0:3] ;

  RegisterFile__b9e413d457c37299 reg_file
  (
    .clk( reg_file__clk ),
    .raddr( reg_file__raddr ),
    .rdata( reg_file__rdata ),
    .reset( reg_file__reset ),
    .waddr( reg_file__waddr ),
    .wdata( reg_file__wdata ),
    .wen( reg_file__wen )
  );

  //-------------------------------------------------------------
  // End of component reg_file
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At ../../VectorCGRA/mem/data/DataMemRTL.py:37
  // @s.update
  // def update_read_without_init():
  //   for i in range( rd_ports ):
  //     s.reg_file.wen[wr_ports + i] = b1(0)
  //     s.reg_file.raddr[i] = s.recv_raddr[i].msg
  //     s.send_rdata[i].msg = s.reg_file.rdata[i]
  // 
  //   for i in range( wr_ports ):
  //     if s.recv_waddr[i].en == b1(1):
  //       s.reg_file.waddr[i] = s.recv_waddr[i].msg
  //       s.reg_file.wdata[i] = s.recv_wdata[i].msg
  //       s.reg_file.wen[i]   = s.recv_wdata[i].en and s.recv_waddr[i].en
  
  always_comb begin : update_read_without_init
    for ( int i = 0; i < __const__rd_ports_at_update_read_without_init; i += 1 ) begin
      reg_file__wen[__const__wr_ports_at_update_read_without_init + i] = 1'd0;
      reg_file__raddr[i] = recv_raddr__msg[i];
      send_rdata__msg[i] = reg_file__rdata[i];
    end
    for ( int i = 0; i < __const__wr_ports_at_update_read_without_init; i += 1 )
      if ( recv_waddr__en[i] == 1'd1 ) begin
        reg_file__waddr[i] = recv_waddr__msg[i];
        reg_file__wdata[i] = recv_wdata__msg[i];
        reg_file__wen[i] = recv_wdata__en[i] && recv_waddr__en[i];
      end
  end

  // PyMTL Update Block Source
  // At ../../VectorCGRA/mem/data/DataMemRTL.py:86
  // @s.update
  // def update_signal():
  //   for i in range( rd_ports ):
  //     s.recv_raddr[i].rdy = s.send_rdata[i].rdy
  //                           # b1( 1 ) # s.send_rdata[i].rdy
  //     s.send_rdata[i].en  = s.recv_raddr[i].en
  //                           # s.send_rdata[i].rdy # s.recv_raddr[i].en
  //   for i in range( wr_ports ):
  //     s.recv_waddr[i].rdy = Bits1( 1 )
  //     s.recv_wdata[i].rdy = Bits1( 1 )
  
  always_comb begin : update_signal
    for ( int i = 0; i < __const__rd_ports_at_update_signal; i += 1 ) begin
      recv_raddr__rdy[i] = send_rdata__rdy[i];
      send_rdata__en[i] = recv_raddr__en[i];
    end
    for ( int i = 0; i < __const__wr_ports_at_update_signal; i += 1 ) begin
      recv_waddr__rdy[i] = 1'd1;
      recv_wdata__rdy[i] = 1'd1;
    end
  end

  // PyMTL Update Block Source
  // At ../../VectorCGRA/mem/data/DataMemRTL.py:77
  // @s.update_ff
  // def update_init():
  //   for i in range( rd_ports ):
  //     if s.recv_raddr[i].en == b1(1):
  //       s.initWrites[s.recv_raddr[i].msg] <<= s.initWrites[s.recv_raddr[i].msg] | b1(1)
  //   for i in range( wr_ports ):
  //     if s.recv_waddr[i].en == b1(1):
  //       s.initWrites[s.recv_waddr[i].msg] <<= s.initWrites[s.recv_waddr[i].msg] | b1(1)
  
  always_ff @(posedge clk) begin : update_init
    for ( int i = 0; i < __const__rd_ports_at_update_init; i += 1 )
      if ( recv_raddr__en[i] == 1'd1 ) begin
        initWrites[recv_raddr__msg[i]] <= initWrites[recv_raddr__msg[i]] | 1'd1;
      end
    for ( int i = 0; i < __const__wr_ports_at_update_init; i += 1 )
      if ( recv_waddr__en[i] == 1'd1 ) begin
        initWrites[recv_waddr__msg[i]] <= initWrites[recv_waddr__msg[i]] | 1'd1;
      end
  end

  assign reg_file__clk = clk;
  assign reg_file__reset = reset;

endmodule


// PyMTL Component NormalQueueCtrlRTL Definition
// At /home/rms/mambaforge/envs/pycgra/lib/python3.7/site-packages/pymtl3/stdlib/rtl/queues.py

module NormalQueueCtrlRTL__num_entries_2
(
  input logic [0:0] clk,
  output logic [1:0] count,
  input logic [0:0] deq_en,
  output logic [0:0] deq_rdy,
  input logic [0:0] enq_en,
  output logic [0:0] enq_rdy,
  output logic [0:0] raddr,
  input logic [0:0] reset,
  output logic [0:0] waddr,
  output logic [0:0] wen
);
  localparam logic [0:0] last_idx = 1'd1;
  localparam logic [1:0] num_entries = 2'd2;
  logic [0:0] deq_xfer ;
  logic [0:0] enq_xfer ;
  logic [0:0] head ;
  logic [0:0] tail ;

  // PyMTL Lambda Block Source
  // At /home/rms/mambaforge/envs/pycgra/lib/python3.7/site-packages/pymtl3/stdlib/rtl/queues.py:86
  // s.deq_rdy //= lambda: ~s.reset & ( s.count > CountType(0) )
  
  always_comb begin : _lambda__s_dut_tile_0__channel_0__queues_0__ctrl_deq_rdy
    deq_rdy = ( ~reset ) & ( count > 2'd0 );
  end

  // PyMTL Lambda Block Source
  // At /home/rms/mambaforge/envs/pycgra/lib/python3.7/site-packages/pymtl3/stdlib/rtl/queues.py:89
  // s.deq_xfer //= lambda: s.deq_en & s.deq_rdy
  
  always_comb begin : _lambda__s_dut_tile_0__channel_0__queues_0__ctrl_deq_xfer
    deq_xfer = deq_en & deq_rdy;
  end

  // PyMTL Lambda Block Source
  // At /home/rms/mambaforge/envs/pycgra/lib/python3.7/site-packages/pymtl3/stdlib/rtl/queues.py:85
  // s.enq_rdy //= lambda: ~s.reset & ( s.count < s.num_entries )
  
  always_comb begin : _lambda__s_dut_tile_0__channel_0__queues_0__ctrl_enq_rdy
    enq_rdy = ( ~reset ) & ( count < num_entries );
  end

  // PyMTL Lambda Block Source
  // At /home/rms/mambaforge/envs/pycgra/lib/python3.7/site-packages/pymtl3/stdlib/rtl/queues.py:88
  // s.enq_xfer //= lambda: s.enq_en & s.enq_rdy
  
  always_comb begin : _lambda__s_dut_tile_0__channel_0__queues_0__ctrl_enq_xfer
    enq_xfer = enq_en & enq_rdy;
  end

  // PyMTL Update Block Source
  // At /home/rms/mambaforge/envs/pycgra/lib/python3.7/site-packages/pymtl3/stdlib/rtl/queues.py:91
  // @s.update_ff
  // def up_reg():
  // 
  //   if s.reset:
  //     s.head  <<= PtrType(0)
  //     s.tail  <<= PtrType(0)
  //     s.count <<= CountType(0)
  // 
  //   else:
  //     if s.deq_xfer:
  //       s.head <<= s.head + PtrType(1) if s.head < s.last_idx else PtrType(0)
  // 
  //     if s.enq_xfer:
  //       s.tail <<= s.tail + PtrType(1) if s.tail < s.last_idx else PtrType(0)
  // 
  //     if s.enq_xfer & ~s.deq_xfer:
  //       s.count <<= s.count + CountType(1)
  //     if ~s.enq_xfer & s.deq_xfer:
  //       s.count <<= s.count - CountType(1)
  
  always_ff @(posedge clk) begin : up_reg
    if ( reset ) begin
      head <= 1'd0;
      tail <= 1'd0;
      count <= 2'd0;
    end
    else begin
      if ( deq_xfer ) begin
        head <= ( head < last_idx ) ? head + 1'd1 : 1'd0;
      end
      if ( enq_xfer ) begin
        tail <= ( tail < last_idx ) ? tail + 1'd1 : 1'd0;
      end
      if ( enq_xfer & ( ~deq_xfer ) ) begin
        count <= count + 2'd1;
      end
      if ( ( ~enq_xfer ) & deq_xfer ) begin
        count <= count - 2'd1;
      end
    end
  end

  assign wen = enq_xfer;
  assign waddr = tail;
  assign raddr = head;

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_CGRAData_32_1_1__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /home/rms/mambaforge/envs/pycgra/lib/python3.7/site-packages/pymtl3/stdlib/rtl/RegisterFile.py

module RegisterFile__e355018d318c7c45
(
  input logic [0:0] clk,
  input logic [0:0] raddr [0:0],
  output CGRAData_32_1_1 rdata [0:0],
  input logic [0:0] reset,
  input logic [0:0] waddr [0:0],
  input CGRAData_32_1_1 wdata [0:0],
  input logic [0:0] wen [0:0]
);
  localparam logic [31:0] __const__rd_ports_at_up_rf_read = 32'd1;
  localparam logic [31:0] __const__wr_ports_at_up_rf_write = 32'd1;
  CGRAData_32_1_1 regs [0:1] ;

  // PyMTL Update Block Source
  // At /home/rms/mambaforge/envs/pycgra/lib/python3.7/site-packages/pymtl3/stdlib/rtl/RegisterFile.py:20
  // @s.update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] = s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int i = 0; i < __const__rd_ports_at_up_rf_read; i += 1 )
      rdata[i] = regs[raddr[i]];
  end

  // PyMTL Update Block Source
  // At /home/rms/mambaforge/envs/pycgra/lib/python3.7/site-packages/pymtl3/stdlib/rtl/RegisterFile.py:32
  // @s.update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int i = 0; i < __const__wr_ports_at_up_rf_write; i += 1 )
      if ( wen[i] ) begin
        regs[waddr[i]] <= wdata[i];
      end
  end

endmodule


// PyMTL Component NormalQueueDpathRTL Definition
// At /home/rms/mambaforge/envs/pycgra/lib/python3.7/site-packages/pymtl3/stdlib/rtl/queues.py

module NormalQueueDpathRTL__EntryType_CGRAData_32_1_1__num_entries_2
(
  input logic [0:0] clk,
  output CGRAData_32_1_1 deq_ret,
  input CGRAData_32_1_1 enq_msg,
  input logic [0:0] raddr,
  input logic [0:0] reset,
  input logic [0:0] waddr,
  input logic [0:0] wen
);
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk ;
  logic [0:0] queue__raddr [0:0] ;
  CGRAData_32_1_1 queue__rdata [0:0] ;
  logic [0:0] queue__reset ;
  logic [0:0] queue__waddr [0:0] ;
  CGRAData_32_1_1 queue__wdata [0:0] ;
  logic [0:0] queue__wen [0:0] ;

  RegisterFile__e355018d318c7c45 queue
  (
    .clk( queue__clk ),
    .raddr( queue__raddr ),
    .rdata( queue__rdata ),
    .reset( queue__reset ),
    .waddr( queue__waddr ),
    .wdata( queue__wdata ),
    .wen( queue__wen )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__raddr[0] = raddr;
  assign deq_ret = queue__rdata[0];
  assign queue__wen[0] = wen;
  assign queue__waddr[0] = waddr;
  assign queue__wdata[0] = enq_msg;

endmodule


// PyMTL Component NormalQueueRTL Definition
// At /home/rms/mambaforge/envs/pycgra/lib/python3.7/site-packages/pymtl3/stdlib/rtl/queues.py

module NormalQueueRTL__EntryType_CGRAData_32_1_1__num_entries_2
(
  input logic [0:0] clk,
  output logic [1:0] count,
  input logic [0:0] reset,
  input logic [0:0] deq__en,
  output logic [0:0] deq__rdy,
  output CGRAData_32_1_1 deq__ret,
  input logic [0:0] enq__en,
  input CGRAData_32_1_1 enq__msg,
  output logic [0:0] enq__rdy
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk ;
  logic [1:0] ctrl__count ;
  logic [0:0] ctrl__deq_en ;
  logic [0:0] ctrl__deq_rdy ;
  logic [0:0] ctrl__enq_en ;
  logic [0:0] ctrl__enq_rdy ;
  logic [0:0] ctrl__raddr ;
  logic [0:0] ctrl__reset ;
  logic [0:0] ctrl__waddr ;
  logic [0:0] ctrl__wen ;

  NormalQueueCtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .deq_en( ctrl__deq_en ),
    .deq_rdy( ctrl__deq_rdy ),
    .enq_en( ctrl__enq_en ),
    .enq_rdy( ctrl__enq_rdy ),
    .raddr( ctrl__raddr ),
    .reset( ctrl__reset ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk ;
  CGRAData_32_1_1 dpath__deq_ret ;
  CGRAData_32_1_1 dpath__enq_msg ;
  logic [0:0] dpath__raddr ;
  logic [0:0] dpath__reset ;
  logic [0:0] dpath__waddr ;
  logic [0:0] dpath__wen ;

  NormalQueueDpathRTL__EntryType_CGRAData_32_1_1__num_entries_2 dpath
  (
    .clk( dpath__clk ),
    .deq_ret( dpath__deq_ret ),
    .enq_msg( dpath__enq_msg ),
    .raddr( dpath__raddr ),
    .reset( dpath__reset ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign ctrl__enq_en = enq__en;
  assign enq__rdy = ctrl__enq_rdy;
  assign ctrl__deq_en = deq__en;
  assign deq__rdy = ctrl__deq_rdy;
  assign count = ctrl__count;
  assign dpath__enq_msg = enq__msg;
  assign deq__ret = dpath__deq_ret;

endmodule


// PyMTL Component ChannelRTL Definition
// At ../../VectorCGRA/noc/ChannelRTL.py

module ChannelRTL__DataType_CGRAData_32_1_1__latency_1
(
  input logic [0:0] clk,
  output logic [1:0] count,
  input logic [0:0] reset,
  input logic [0:0] recv__en,
  input CGRAData_32_1_1 recv__msg,
  output logic [0:0] recv__rdy,
  output logic [0:0] send__en,
  output CGRAData_32_1_1 send__msg,
  input logic [0:0] send__rdy
);
  localparam CGRAData_32_1_1 data = { 32'd0, 1'd0, 1'd0 };
  localparam logic [31:0] latency = 32'd1;
  //-------------------------------------------------------------
  // Component queues[0:0]
  //-------------------------------------------------------------

  logic [0:0] queues__clk [0:0] ;
  logic [1:0] queues__count [0:0] ;
  logic [0:0] queues__reset [0:0] ;
  logic [0:0] queues__deq__en [0:0] ;
  logic [0:0] queues__deq__rdy [0:0] ;
  CGRAData_32_1_1 queues__deq__ret [0:0] ;
  logic [0:0] queues__enq__en [0:0] ;
  CGRAData_32_1_1 queues__enq__msg [0:0] ;
  logic [0:0] queues__enq__rdy [0:0] ;

  NormalQueueRTL__EntryType_CGRAData_32_1_1__num_entries_2 queues__0
  (
    .clk( queues__clk[0] ),
    .count( queues__count[0] ),
    .reset( queues__reset[0] ),
    .deq__en( queues__deq__en[0] ),
    .deq__rdy( queues__deq__rdy[0] ),
    .deq__ret( queues__deq__ret[0] ),
    .enq__en( queues__enq__en[0] ),
    .enq__msg( queues__enq__msg[0] ),
    .enq__rdy( queues__enq__rdy[0] )
  );

  //-------------------------------------------------------------
  // End of component queues[0:0]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At ../../VectorCGRA/noc/ChannelRTL.py:35
  //   @s.update
  //   def process():
  //     if s.recv.msg.bypass == b1( 0 ):
  //       s.recv.rdy = s.queues[0].enq.rdy
  //       s.queues[0].enq.msg = s.recv.msg
  //       s.queues[0].enq.en  = s.recv.en and s.queues[0].enq.rdy
  //       for i in range(s.latency - 1):
  //         s.queues[i+1].enq.msg = s.queues[i].deq.ret
  //         s.queues[i+1].enq.en  = s.queues[i].deq.rdy and s.queues[i+1].enq.rdy
  //         s.queues[i].deq.en    = s.queues[i+1].enq.en
  // 
  //       s.send.msg  = s.queues[s.latency-1].deq.ret
  //       s.send.en   = s.send.rdy and s.queues[s.latency-1].deq.rdy
  //       s.queues[s.latency-1].deq.en   = s.send.en
  //     else:
  //       s.send.msg = s.data
  //       s.send.msg.payload = s.recv.msg.payload
  //       s.send.msg.predicate = s.recv.msg.predicate
  //       s.send.msg.bypass = b1( 0 )
  //       s.send.en = s.send.rdy and s.recv.en
  //       s.recv.rdy = s.send.rdy
  
  always_comb begin : process
    if ( recv__msg.bypass == 1'd0 ) begin
      recv__rdy = queues__enq__rdy[0];
      queues__enq__msg[0] = recv__msg;
      queues__enq__en[0] = recv__en && queues__enq__rdy[0];
      for ( int i = 0; i < latency - 1; i += 1 ) begin
        queues__enq__msg[i + 1] = queues__deq__ret[i];
        queues__enq__en[i + 1] = queues__deq__rdy[i] && queues__enq__rdy[i + 1];
        queues__deq__en[i] = queues__enq__en[i + 1];
      end
      send__msg = queues__deq__ret[latency - 1];
      send__en = send__rdy && queues__deq__rdy[latency - 1];
      queues__deq__en[latency - 1] = send__en;
    end
    else begin
      send__msg = data;
      send__msg.payload = recv__msg.payload;
      send__msg.predicate = recv__msg.predicate;
      send__msg.bypass = 1'd0;
      send__en = send__rdy && recv__en;
      recv__rdy = send__rdy;
    end
  end

  assign queues__clk[0] = clk;
  assign queues__reset[0] = reset;
  assign count = queues__count[0];

endmodule


// PyMTL Component ConstQueueRTL Definition
// Full name: ConstQueueRTL__DataType_CGRAData_32_1_1__const_list_[CGRAData_32_1_1(Bits32(0x00000000),Bits1(0x0),Bits1(0x0))]
// At ../../VectorCGRA/mem/const/ConstQueueRTL.py

module ConstQueueRTL__2f4560623c67a554
(
  input logic [0:0] clk,
  input logic [0:0] reset,
  output logic [0:0] send_const__en,
  output CGRAData_32_1_1 send_const__msg,
  input logic [0:0] send_const__rdy
);
  localparam CGRAData_32_1_1 const_queue [0:0] = '{ { 32'd0, 1'd0, 1'd0 } };
  localparam logic [31:0] __const__num_const_at_update_raddr = 32'd1;
  logic [0:0] cur ;

  // PyMTL Update Block Source
  // At ../../VectorCGRA/mem/const/ConstQueueRTL.py:37
  // @s.update
  // def load():
  //   s.send_const.msg = s.const_queue[ s.cur ]
  
  always_comb begin : load
    send_const__msg = const_queue[cur];
  end

  // PyMTL Update Block Source
  // At ../../VectorCGRA/mem/const/ConstQueueRTL.py:41
  // @s.update
  // def update_en():
  //   s.send_const.en = s.send_const.rdy
  
  always_comb begin : update_en
    send_const__en = send_const__rdy;
  end

  // PyMTL Update Block Source
  // At ../../VectorCGRA/mem/const/ConstQueueRTL.py:45
  // @s.update_ff
  // def update_raddr():
  //   if s.send_const.rdy:
  //     if s.cur + AddrType( 1 )  >= AddrType( num_const ):
  //       s.cur <<= AddrType( 0 )
  //     else:
  //       s.cur <<= s.cur + AddrType( 1 )
  
  always_ff @(posedge clk) begin : update_raddr
    if ( send_const__rdy ) begin
      if ( ( cur + 1'd1 ) >= 1'd1 ) begin
        cur <= 1'd0;
      end
      else
        cur <= cur + 1'd1;
    end
  end

endmodule


// PyMTL Component CrossbarRTL Definition
// Full name: CrossbarRTL__DataType_CGRAData_32_1_1__PredicateType_CGRAData_1_1__CtrlType_CGRAConfig_6_4_8_8__num_inports_10__num_outports_12__bypass_point_4__id_0
// At ../../VectorCGRA/noc/CrossbarRTL.py

module CrossbarRTL__874305e17dbe6b02
(
  input logic [0:0] clk,
  input logic [0:0] reset,
  input logic [0:0] recv_data__en [0:9],
  input CGRAData_32_1_1 recv_data__msg [0:9],
  output logic [0:0] recv_data__rdy [0:9],
  input logic [0:0] recv_opt__en,
  input CGRAConfig_6_4_8_8 recv_opt__msg,
  output logic [0:0] recv_opt__rdy,
  output logic [0:0] send_data__en [0:11],
  output CGRAData_32_1_1 send_data__msg [0:11],
  input logic [0:0] send_data__rdy [0:11],
  output logic [0:0] send_predicate__en,
  output CGRAData_1_1 send_predicate__msg,
  input logic [0:0] send_predicate__rdy
);
  localparam logic [31:0] bypass_point = 32'd4;
  localparam logic [5:0] __const__OPT_START = 6'd0;
  localparam logic [31:0] __const__num_inports_at_update_signal = 32'd10;
  localparam logic [31:0] __const__num_outports_at_update_signal = 32'd12;
  logic [0:0] __tmpvar__update_signal_out_rdy ;
  logic [3:0] __tmpvar__update_signal_in_dir ;

  // PyMTL Update Block Source
  // At ../../VectorCGRA/noc/CrossbarRTL.py:34
  //     @s.update
  //     def update_signal():
  //       out_rdy = b1( 0 )
  //       s.send_predicate.en = b1( 0 )
  //       # predicate_out_rdy = b1( 0 )
  //       # For predication register update. 'predicate' and 'predicate_in' no need
  //       # to be active at the same time. Specifically, the 'predicate' is for
  //       # the operation at the current cycle while the 'predicate_in' accumulates
  //       # the predicate and pushes into the predicate register that will be used
  //       # in the future.
  //       if s.recv_opt.msg.predicate == b1( 1 ):
  //         # s.send_predicate.msg.payload = b1( 0 )
  //         # s.send_predicate.msg.predicate = b1( 0 )
  //         s.send_predicate.msg = PredicateType( b1(0), b1(0) )
  //       if s.recv_opt.msg.ctrl != OPT_START:
  //         for i in range( num_inports ):
  //           # Set predicate once the recv_data is stable (i.e., en == true).
  //           if s.recv_opt.msg.predicate_in[i] == b1( 1 ) and s.recv_data[i].en == b1( 1 ):
  //             s.send_predicate.en = b1( 1 )
  //             s.send_predicate.msg.payload = b1( 1 )
  //             s.send_predicate.msg.predicate = s.send_predicate.msg.predicate | s.recv_data[i].msg.predicate
  //             # predicate_out_rdy = b1( 1 )
  //         for i in range( num_outports ):
  //           in_dir  = s.recv_opt.msg.outport[i]
  //           out_rdy = out_rdy | s.send_data[i].rdy
  // #          s.send_data[i].msg.bypass = b1( 0 ) 
  //           if in_dir > OutType( 0 ) and s.send_data[i].rdy:
  //             in_dir = in_dir - OutType( 1 )
  //             s.recv_data[in_dir].rdy = s.send_data[i].rdy
  //             s.send_data[i].en       = s.recv_data[in_dir].en
  //             if s.send_data[i].en and s.recv_data[in_dir].rdy:
  //               s.send_data[i].msg.payload   = s.recv_data[in_dir].msg.payload
  //               s.send_data[i].msg.predicate = s.recv_data[in_dir].msg.predicate
  // #              s.send_data[i].msg = s.recv_data[in_dir].msg
  //               s.send_data[i].msg.bypass    = s.recv_data[in_dir].msg.bypass
  //             # The generate one can be send to other tile without buffering,
  //             # but buffering is still needed when 'other tile' is yourself
  //             # (i.e., generating output to self input). Here we avoid self 
  //             # connecting by checking whether the inport belongs to FU and
  //             # outport be towards to remote tiles to eliminate combinational
  //             # loop.
  //             if in_dir >= OutType( s.bypass_point ) and i<s.bypass_point:
  //               s.send_data[i].msg.bypass = b1( 1 ) 
  // #              print("in crossbar ", s, " set bypass ... s.recv_opt.msg.outport[", i, "]: ", s.recv_opt.msg.outport[i])
  //             else:
  //               s.send_data[i].msg.bypass = b1( 0 ) 
  // #            print("in crossbar if... s.send_data[", i, "].msg: ", s.send_data[i].msg, "; recv.rdy: ", s.recv_data[in_dir].rdy)
  //           else:
  //             s.send_data[i].en  = b1( 0 )
  //             #s.send_data[i].msg = b1( 0 )
  // #            print("in crossbar else... s.send_data[", i, "].msg: ", s.send_data[i].msg)
  // 
  //       else:
  //         for i in range( num_outports ):
  // #          s.send_data[i].msg.bypass = b1( 0 ) 
  //           s.send_data[i].en = b1( 0 )
  //       s.recv_opt.rdy = out_rdy# and predicate_out_rdy
  
  always_comb begin : update_signal
    __tmpvar__update_signal_out_rdy = 1'd0;
    send_predicate__en = 1'd0;
    if ( recv_opt__msg.predicate == 1'd1 ) begin
      send_predicate__msg = { 1'd0, 1'd0 };
    end
    if ( recv_opt__msg.ctrl != __const__OPT_START ) begin
      for ( int i = 0; i < __const__num_inports_at_update_signal; i += 1 )
        if ( ( recv_opt__msg.predicate_in[i] == 1'd1 ) && ( recv_data__en[i] == 1'd1 ) ) begin
          send_predicate__en = 1'd1;
          send_predicate__msg.payload = 1'd1;
          send_predicate__msg.predicate = send_predicate__msg.predicate | recv_data__msg[i].predicate;
        end
      for ( int i = 0; i < __const__num_outports_at_update_signal; i += 1 ) begin
        __tmpvar__update_signal_in_dir = recv_opt__msg.outport[i];
        __tmpvar__update_signal_out_rdy = __tmpvar__update_signal_out_rdy | send_data__rdy[i];
        if ( ( __tmpvar__update_signal_in_dir > 4'd0 ) && send_data__rdy[i] ) begin
          __tmpvar__update_signal_in_dir = __tmpvar__update_signal_in_dir - 4'd1;
          recv_data__rdy[__tmpvar__update_signal_in_dir] = send_data__rdy[i];
          send_data__en[i] = recv_data__en[__tmpvar__update_signal_in_dir];
          if ( send_data__en[i] && recv_data__rdy[__tmpvar__update_signal_in_dir] ) begin
            send_data__msg[i].payload = recv_data__msg[__tmpvar__update_signal_in_dir].payload;
            send_data__msg[i].predicate = recv_data__msg[__tmpvar__update_signal_in_dir].predicate;
            send_data__msg[i].bypass = recv_data__msg[__tmpvar__update_signal_in_dir].bypass;
          end
          if ( ( __tmpvar__update_signal_in_dir >= 4'( bypass_point ) ) && ( i < bypass_point ) ) begin
            send_data__msg[i].bypass = 1'd1;
          end
          else
            send_data__msg[i].bypass = 1'd0;
        end
        else
          send_data__en[i] = 1'd0;
      end
    end
    else
      for ( int i = 0; i < __const__num_outports_at_update_signal; i += 1 )
        send_data__en[i] = 1'd0;
    recv_opt__rdy = __tmpvar__update_signal_out_rdy;
  end

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_CGRAConfig_6_4_8_8__nregs_8__rd_ports_1__wr_ports_1__const_zero_False
// At /home/rms/mambaforge/envs/pycgra/lib/python3.7/site-packages/pymtl3/stdlib/rtl/RegisterFile.py

module RegisterFile__ff3fced67c114009
(
  input logic [0:0] clk,
  input logic [2:0] raddr [0:0],
  output CGRAConfig_6_4_8_8 rdata [0:0],
  input logic [0:0] reset,
  input logic [2:0] waddr [0:0],
  input CGRAConfig_6_4_8_8 wdata [0:0],
  input logic [0:0] wen [0:0]
);
  localparam logic [31:0] __const__rd_ports_at_up_rf_read = 32'd1;
  localparam logic [31:0] __const__wr_ports_at_up_rf_write = 32'd1;
  CGRAConfig_6_4_8_8 regs [0:7] ;

  // PyMTL Update Block Source
  // At /home/rms/mambaforge/envs/pycgra/lib/python3.7/site-packages/pymtl3/stdlib/rtl/RegisterFile.py:20
  // @s.update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] = s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int i = 0; i < __const__rd_ports_at_up_rf_read; i += 1 )
      rdata[i] = regs[raddr[i]];
  end

  // PyMTL Update Block Source
  // At /home/rms/mambaforge/envs/pycgra/lib/python3.7/site-packages/pymtl3/stdlib/rtl/RegisterFile.py:32
  // @s.update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int i = 0; i < __const__wr_ports_at_up_rf_write; i += 1 )
      if ( wen[i] ) begin
        regs[waddr[i]] <= wdata[i];
      end
  end

endmodule


// PyMTL Component CtrlMemRTL Definition
// Full name: CtrlMemRTL__CtrlType_CGRAConfig_6_4_8_8__ctrl_mem_size_8__num_ctrl_4
// At ../../VectorCGRA/mem/ctrl/CtrlMemRTL.py

module CtrlMemRTL__ebe00becbc7c6d54
(
  input logic [0:0] clk,
  input logic [0:0] reset,
  input logic [0:0] recv_ctrl__en,
  input CGRAConfig_6_4_8_8 recv_ctrl__msg,
  output logic [0:0] recv_ctrl__rdy,
  input logic [0:0] recv_waddr__en,
  input logic [2:0] recv_waddr__msg,
  output logic [0:0] recv_waddr__rdy,
  output logic [0:0] send_ctrl__en,
  output CGRAConfig_6_4_8_8 send_ctrl__msg,
  input logic [0:0] send_ctrl__rdy
);
  localparam logic [31:0] __const__num_ctrl_at_update_signal = 32'd4;
  localparam logic [5:0] __const__OPT_START = 6'd0;
  localparam logic [31:0] __const__num_ctrl_at_update_raddr = 32'd4;
  localparam logic [2:0] __const__last_item_at_update_raddr = 3'd7;
  logic [2:0] times ;
  //-------------------------------------------------------------
  // Component reg_file
  //-------------------------------------------------------------

  logic [0:0] reg_file__clk ;
  logic [2:0] reg_file__raddr [0:0] ;
  CGRAConfig_6_4_8_8 reg_file__rdata [0:0] ;
  logic [0:0] reg_file__reset ;
  logic [2:0] reg_file__waddr [0:0] ;
  CGRAConfig_6_4_8_8 reg_file__wdata [0:0] ;
  logic [0:0] reg_file__wen [0:0] ;

  RegisterFile__ff3fced67c114009 reg_file
  (
    .clk( reg_file__clk ),
    .raddr( reg_file__raddr ),
    .rdata( reg_file__rdata ),
    .reset( reg_file__reset ),
    .waddr( reg_file__waddr ),
    .wdata( reg_file__wdata ),
    .wen( reg_file__wen )
  );

  //-------------------------------------------------------------
  // End of component reg_file
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At ../../VectorCGRA/mem/ctrl/CtrlMemRTL.py:42
  // @s.update
  // def update_signal():
  //   if s.times == TimeType( num_ctrl ) or s.reg_file.rdata[0].ctrl == OPT_START:
  //     s.send_ctrl.en = b1( 0 )
  //   else:
  //     s.send_ctrl.en  = s.send_ctrl.rdy # s.recv_raddr[i].rdy
  //   s.recv_waddr.rdy = b1( 1 )
  //   s.recv_ctrl.rdy = b1( 1 )
  
  always_comb begin : update_signal
    if ( ( times == 3'd4 ) || ( reg_file__rdata[0].ctrl == __const__OPT_START ) ) begin
      send_ctrl__en = 1'd0;
    end
    else
      send_ctrl__en = send_ctrl__rdy;
    recv_waddr__rdy = 1'd1;
    recv_ctrl__rdy = 1'd1;
  end

  // PyMTL Update Block Source
  // At ../../VectorCGRA/mem/ctrl/CtrlMemRTL.py:51
  // @s.update_ff
  // def update_raddr():
  //   if s.reg_file.rdata[0].ctrl != OPT_START:
  //     if s.times < TimeType( num_ctrl ):
  //       s.times <<= s.times + TimeType( 1 )
  //     if s.reg_file.raddr[0] < last_item:
  //       s.reg_file.raddr[0] <<= s.reg_file.raddr[0] + AddrType( 1 )
  //     else:
  //       s.reg_file.raddr[0] <<= AddrType( 0 )
  
  always_ff @(posedge clk) begin : update_raddr
    if ( reg_file__rdata[0].ctrl != __const__OPT_START ) begin
      if ( times < 3'd4 ) begin
        times <= times + 3'd1;
      end
      if ( reg_file__raddr[0] < __const__last_item_at_update_raddr ) begin
        reg_file__raddr[0] <= reg_file__raddr[0] + 3'd1;
      end
      else
        reg_file__raddr[0] <= 3'd0;
    end
  end

  assign reg_file__clk = clk;
  assign reg_file__reset = reset;
  assign send_ctrl__msg = reg_file__rdata[0];
  assign reg_file__waddr[0] = recv_waddr__msg;
  assign reg_file__wdata[0] = recv_ctrl__msg;
  assign reg_file__wen[0] = recv_waddr__en;

endmodule


// PyMTL Component PhiRTL Definition
// Full name: PhiRTL__DataType_CGRAData_32_1_1__PredicateType_CGRAData_1_1__CtrlType_CGRAConfig_6_4_8_8__num_inports_4__num_outports_2__data_mem_size_8
// At ../../VectorCGRA/fu/single/PhiRTL.py

module PhiRTL__a050676efb0a4b04
(
  input logic [0:0] clk,
  input logic [0:0] initial_carry_in,
  output logic [0:0] initial_carry_out,
  input logic [1:0] recv_in_count [0:3],
  input logic [0:0] reset,
  input logic [0:0] from_mem_rdata__en,
  input CGRAData_32_1_1 from_mem_rdata__msg,
  output logic [0:0] from_mem_rdata__rdy,
  input logic [0:0] recv_const__en,
  input CGRAData_32_1_1 recv_const__msg,
  output logic [0:0] recv_const__rdy,
  input logic [0:0] recv_in__en [0:3],
  input CGRAData_32_1_1 recv_in__msg [0:3],
  output logic [0:0] recv_in__rdy [0:3],
  input logic [0:0] recv_opt__en,
  input CGRAConfig_6_4_8_8 recv_opt__msg,
  output logic [0:0] recv_opt__rdy,
  input logic [0:0] recv_predicate__en,
  input CGRAData_1_1 recv_predicate__msg,
  output logic [0:0] recv_predicate__rdy,
  output logic [0:0] send_out__en [0:1],
  output CGRAData_32_1_1 send_out__msg [0:1],
  input logic [0:0] send_out__rdy [0:1],
  output logic [0:0] to_mem_raddr__en,
  output logic [2:0] to_mem_raddr__msg,
  input logic [0:0] to_mem_raddr__rdy,
  output logic [0:0] to_mem_waddr__en,
  output logic [2:0] to_mem_waddr__msg,
  input logic [0:0] to_mem_waddr__rdy,
  output logic [0:0] to_mem_wdata__en,
  output CGRAData_32_1_1 to_mem_wdata__msg,
  input logic [0:0] to_mem_wdata__rdy
);
  localparam CGRAData_32_1_1 const_zero = { 32'd0, 1'd0, 1'd0 };
  localparam logic [31:0] __const__num_outports_at_update_signal = 32'd2;
  localparam logic [31:0] __const__num_inports_at_comb_logic = 32'd4;
  localparam logic [31:0] __const__num_outports_at_comb_logic = 32'd2;
  localparam logic [5:0] __const__OPT_PHI = 6'd17;
  localparam logic [5:0] __const__OPT_PHI_CONST = 6'd32;
  logic [2:0] __tmpvar__comb_logic_in0 ;
  logic [2:0] __tmpvar__comb_logic_in1 ;

  // PyMTL Update Block Source
  // At ../../VectorCGRA/fu/single/PhiRTL.py:30
  // @s.update
  // def comb_logic():
  // 
  //   # For pick input register
  //   in0 = FuInType( 0 )
  //   in1 = FuInType( 0 )
  //   for i in range( num_inports ):
  //     s.recv_in[i].rdy = b1( 0 )
  // 
  //   s.recv_predicate.rdy = b1( 0 )
  // 
  //   if s.recv_opt.en:
  //     if s.recv_opt.msg.fu_in[0] != FuInType( 0 ):
  //       in0 = s.recv_opt.msg.fu_in[0] - FuInType( 1 )
  //       s.recv_in[in0].rdy = b1( 1 )
  //     if s.recv_opt.msg.fu_in[1] != FuInType( 0 ):
  //       in1 = s.recv_opt.msg.fu_in[1] - FuInType( 1 )
  //       s.recv_in[in1].rdy = b1( 1 )
  //     if s.recv_opt.msg.predicate == b1( 1 ):
  //       s.recv_predicate.rdy = b1( 1 )
  // 
  //   for j in range( num_outports ):
  //     s.send_out[j].en = s.recv_opt.en
  // 
  //   if s.recv_opt.msg.ctrl == OPT_PHI:
  //     if s.recv_in[in0].msg.predicate == Bits1( 1 ):
  //       s.send_out[0].msg.payload   = s.recv_in[in0].msg.payload
  //       s.send_out[0].msg.predicate = Bits1( 1 )
  //     elif s.recv_in[in1].msg.predicate == Bits1( 1 ):
  //       s.send_out[0].msg.payload   = s.recv_in[in1].msg.payload
  //       s.send_out[0].msg.predicate = Bits1( 1 )
  //     else: # No predecessor is active.
  //       s.send_out[0].msg.payload   = s.recv_in[in0].msg.payload
  //       s.send_out[0].msg.predicate = Bits1( 0 )
  //     if s.recv_opt.en and ( s.recv_in_count[in0] == CountType( 0 ) or\
  //                            s.recv_in_count[in1] == CountType( 0 ) ):
  //       s.recv_in[in0].rdy   = b1( 0 )
  //       s.recv_in[in1].rdy   = b1( 0 )
  //       s.recv_predicate.rdy = b1( 0 )
  //       s.send_out[0].msg.predicate = b1( 0 )
  // 
  //     if s.recv_opt.msg.predicate     == b1( 1 ) and\
  //        s.recv_predicate.msg.payload == b1( 0 ):
  //       s.recv_predicate.rdy = b1( 0 )
  //       s.recv_in[in0].rdy   = b1( 0 )
  //       s.recv_in[in1].rdy   = b1( 0 )
  // 
  //   elif s.recv_opt.msg.ctrl == OPT_PHI_CONST:
  // 
  //     s.send_out[0].msg.predicate = Bits1( 1 )
  //     if s.recv_in[in0].msg.predicate == Bits1( 1 ):
  //       s.send_out[0].msg.payload   = s.recv_in[in0].msg.payload
  //     else:
  //       s.send_out[0].msg.payload   = s.recv_const.msg.payload
  // 
  //     # Predication signal not arrive yet.
  //     if s.recv_opt.msg.predicate     == b1( 1 ) and\
  //        s.recv_predicate.msg.payload == b1( 0 ):
  //       #s.recv_predicate.rdy = b1( 0 )
  //       s.recv_in[in0].rdy   = b1( 0 )
  // 
  //   else:
  //     for j in range( num_outports ):
  //       s.send_out[j].en = b1( 0 )
  // 
  //   if s.recv_opt.msg.predicate == b1( 1 ):
  // 
  //     s.send_out[0].msg.predicate = s.send_out[0].msg.predicate and\
  //                                   s.recv_predicate.msg.predicate
  //     # The PHI_CONST operation executed an the first time does not need predication signal.
  //     if s.recv_opt.msg.ctrl == OPT_PHI_CONST:
  //       if s.recv_predicate.msg.payload == b1( 0 ):
  //         s.send_out[0].msg.predicate = b1( 1 )
  
  always_comb begin : comb_logic
    __tmpvar__comb_logic_in0 = 3'd0;
    __tmpvar__comb_logic_in1 = 3'd0;
    for ( int i = 0; i < __const__num_inports_at_comb_logic; i += 1 )
      recv_in__rdy[i] = 1'd0;
    recv_predicate__rdy = 1'd0;
    if ( recv_opt__en ) begin
      if ( recv_opt__msg.fu_in[0] != 3'd0 ) begin
        __tmpvar__comb_logic_in0 = recv_opt__msg.fu_in[0] - 3'd1;
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd1;
      end
      if ( recv_opt__msg.fu_in[1] != 3'd0 ) begin
        __tmpvar__comb_logic_in1 = recv_opt__msg.fu_in[1] - 3'd1;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd1;
      end
      if ( recv_opt__msg.predicate == 1'd1 ) begin
        recv_predicate__rdy = 1'd1;
      end
    end
    for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
      send_out__en[j] = recv_opt__en;
    if ( recv_opt__msg.ctrl == __const__OPT_PHI ) begin
      if ( recv_in__msg[__tmpvar__comb_logic_in0].predicate == 1'd1 ) begin
        send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in0].payload;
        send_out__msg[0].predicate = 1'd1;
      end
      else if ( recv_in__msg[__tmpvar__comb_logic_in1].predicate == 1'd1 ) begin
        send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in1].payload;
        send_out__msg[0].predicate = 1'd1;
      end
      else begin
        send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in0].payload;
        send_out__msg[0].predicate = 1'd0;
      end
      if ( recv_opt__en && ( ( recv_in_count[__tmpvar__comb_logic_in0] == 2'd0 ) || ( recv_in_count[__tmpvar__comb_logic_in1] == 2'd0 ) ) ) begin
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd0;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd0;
        recv_predicate__rdy = 1'd0;
        send_out__msg[0].predicate = 1'd0;
      end
      if ( ( recv_opt__msg.predicate == 1'd1 ) && ( recv_predicate__msg.payload == 1'd0 ) ) begin
        recv_predicate__rdy = 1'd0;
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd0;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd0;
      end
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_PHI_CONST ) begin
      send_out__msg[0].predicate = 1'd1;
      if ( recv_in__msg[__tmpvar__comb_logic_in0].predicate == 1'd1 ) begin
        send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in0].payload;
      end
      else
        send_out__msg[0].payload = recv_const__msg.payload;
      if ( ( recv_opt__msg.predicate == 1'd1 ) && ( recv_predicate__msg.payload == 1'd0 ) ) begin
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd0;
      end
    end
    else
      for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
        send_out__en[j] = 1'd0;
    if ( recv_opt__msg.predicate == 1'd1 ) begin
      send_out__msg[0].predicate = send_out__msg[0].predicate && recv_predicate__msg.predicate;
      if ( recv_opt__msg.ctrl == __const__OPT_PHI_CONST ) begin
        if ( recv_predicate__msg.payload == 1'd0 ) begin
          send_out__msg[0].predicate = 1'd1;
        end
      end
    end
  end

  // PyMTL Update Block Source
  // At ../../VectorCGRA/fu/basic/Fu.py:49
  // @s.update
  // def update_mem():
  //   s.to_mem_waddr.en    = b1( 0 )
  //   s.to_mem_wdata.en    = b1( 0 )
  //   s.to_mem_wdata.msg   = s.const_zero
  //   s.to_mem_waddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.en    = b1( 0 )
  //   s.from_mem_rdata.rdy = b1( 0 )
  
  always_comb begin : update_mem
    to_mem_waddr__en = 1'd0;
    to_mem_wdata__en = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 3'd0;
    to_mem_raddr__msg = 3'd0;
    to_mem_raddr__en = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At ../../VectorCGRA/fu/basic/Fu.py:43
  // @s.update
  // def update_signal():
  //   for j in range( num_outports ):
  //     s.recv_const.rdy = s.send_out[j].rdy or s.recv_const.rdy
  //     s.recv_opt.rdy = s.send_out[j].rdy or s.recv_opt.rdy
  
  always_comb begin : update_signal
    for ( int j = 0; j < __const__num_outports_at_update_signal; j += 1 ) begin
      recv_const__rdy = send_out__rdy[j] || recv_const__rdy;
      recv_opt__rdy = send_out__rdy[j] || recv_opt__rdy;
    end
  end

endmodule


// PyMTL Component AdderRTL Definition
// Full name: AdderRTL__DataType_CGRAData_32_1_1__PredicateType_CGRAData_1_1__CtrlType_CGRAConfig_6_4_8_8__num_inports_4__num_outports_2__data_mem_size_8
// At ../../VectorCGRA/fu/single/AdderRTL.py

module AdderRTL__a050676efb0a4b04
(
  input logic [0:0] clk,
  input logic [0:0] initial_carry_in,
  output logic [0:0] initial_carry_out,
  input logic [1:0] recv_in_count [0:3],
  input logic [0:0] reset,
  input logic [0:0] from_mem_rdata__en,
  input CGRAData_32_1_1 from_mem_rdata__msg,
  output logic [0:0] from_mem_rdata__rdy,
  input logic [0:0] recv_const__en,
  input CGRAData_32_1_1 recv_const__msg,
  output logic [0:0] recv_const__rdy,
  input logic [0:0] recv_in__en [0:3],
  input CGRAData_32_1_1 recv_in__msg [0:3],
  output logic [0:0] recv_in__rdy [0:3],
  input logic [0:0] recv_opt__en,
  input CGRAConfig_6_4_8_8 recv_opt__msg,
  output logic [0:0] recv_opt__rdy,
  input logic [0:0] recv_predicate__en,
  input CGRAData_1_1 recv_predicate__msg,
  output logic [0:0] recv_predicate__rdy,
  output logic [0:0] send_out__en [0:1],
  output CGRAData_32_1_1 send_out__msg [0:1],
  input logic [0:0] send_out__rdy [0:1],
  output logic [0:0] to_mem_raddr__en,
  output logic [2:0] to_mem_raddr__msg,
  input logic [0:0] to_mem_raddr__rdy,
  output logic [0:0] to_mem_waddr__en,
  output logic [2:0] to_mem_waddr__msg,
  input logic [0:0] to_mem_waddr__rdy,
  output logic [0:0] to_mem_wdata__en,
  output CGRAData_32_1_1 to_mem_wdata__msg,
  input logic [0:0] to_mem_wdata__rdy
);
  localparam CGRAData_32_1_1 const_one = { 32'd1, 1'd1, 1'd0 };
  localparam CGRAData_32_1_1 const_zero = { 32'd0, 1'd0, 1'd0 };
  localparam logic [31:0] __const__num_outports_at_update_signal = 32'd2;
  localparam logic [31:0] __const__num_inports_at_comb_logic = 32'd4;
  localparam logic [31:0] __const__num_outports_at_comb_logic = 32'd2;
  localparam logic [5:0] __const__OPT_ADD = 6'd2;
  localparam logic [5:0] __const__OPT_ADD_CONST = 6'd25;
  localparam logic [5:0] __const__OPT_INC = 6'd3;
  localparam logic [5:0] __const__OPT_SUB = 6'd4;
  localparam logic [5:0] __const__OPT_PAS = 6'd31;
  logic [2:0] __tmpvar__comb_logic_in0 ;
  logic [2:0] __tmpvar__comb_logic_in1 ;

  // PyMTL Update Block Source
  // At ../../VectorCGRA/fu/single/AdderRTL.py:31
  //     @s.update
  //     def comb_logic():
  // 
  //       # For pick input register
  //       in0 = FuInType( 0 )
  //       in1 = FuInType( 0 )
  //       for i in range( num_inports ):
  //         s.recv_in[i].rdy = b1( 0 )
  // 
  //       s.recv_predicate.rdy = b1( 0 )
  // 
  //       if s.recv_opt.en:
  //         if s.recv_opt.msg.fu_in[0] != FuInType( 0 ):
  //           in0 = s.recv_opt.msg.fu_in[0] - FuInType( 1 )
  //           s.recv_in[in0].rdy = b1( 1 )
  //         if s.recv_opt.msg.fu_in[1] != FuInType( 0 ):
  //           in1 = s.recv_opt.msg.fu_in[1] - FuInType( 1 )
  //           s.recv_in[in1].rdy = b1( 1 )
  //         if s.recv_opt.msg.predicate == b1( 1 ):
  //           s.recv_predicate.rdy = b1( 1 )
  // 
  //       s.send_out[0].msg.predicate = s.recv_in[in0].msg.predicate and\
  //                                       s.recv_in[in1].msg.predicate
  // 
  //       for j in range( num_outports ):
  //         s.send_out[j].en = s.recv_opt.en
  // 
  // #      s.send_out[0].en = s.recv_opt.en
  // 
  //       if s.recv_opt.msg.ctrl == OPT_ADD:
  //         s.send_out[0].msg.payload = s.recv_in[in0].msg.payload + s.recv_in[in1].msg.payload
  //         s.send_out[0].msg.predicate = s.recv_in[in0].msg.predicate and s.recv_in[in1].msg.predicate
  //         if s.recv_opt.en and ( s.recv_in_count[in0] == CountType( 0 ) or\
  //                                s.recv_in_count[in1] == CountType( 0 ) ):
  //           s.recv_in[in0].rdy = b1( 0 )
  //           s.recv_in[in1].rdy = b1( 0 )
  //           s.send_out[0].msg.predicate = b1( 0 )
  //       elif s.recv_opt.msg.ctrl == OPT_ADD_CONST:
  //         s.send_out[0].msg.payload = s.recv_in[in0].msg.payload + s.recv_const.msg.payload
  //         s.send_out[0].msg.predicate = s.recv_in[in0].msg.predicate
  //       elif s.recv_opt.msg.ctrl == OPT_INC:
  //         s.send_out[0].msg.payload = s.recv_in[in0].msg.payload + s.const_one.payload
  //         s.send_out[0].msg.predicate = s.recv_in[in0].msg.predicate
  //       elif s.recv_opt.msg.ctrl == OPT_SUB:
  //         s.send_out[0].msg.payload = s.recv_in[in0].msg.payload - s.recv_in[in1].msg.payload
  //         s.send_out[0].msg.predicate = s.recv_in[in0].msg.predicate
  //         if s.recv_opt.en and ( s.recv_in_count[in0] == CountType( 0 ) or\
  //                                s.recv_in_count[in1] == CountType( 0 ) ):
  //           s.recv_in[in0].rdy = b1( 0 )
  //           s.recv_in[in1].rdy = b1( 0 )
  //           s.send_out[0].msg.predicate = b1( 0 )
  //       elif s.recv_opt.msg.ctrl == OPT_PAS:
  //         s.send_out[0].msg.payload = s.recv_in[in0].msg.payload
  //         s.send_out[0].msg.predicate = s.recv_in[in0].msg.predicate
  //       else:
  //         for j in range( num_outports ):
  //           s.send_out[j].en = b1( 0 )
  // 
  //       if s.recv_opt.msg.predicate == b1( 1 ):
  //         s.send_out[0].msg.predicate = s.send_out[0].msg.predicate and\
  //                                       s.recv_predicate.msg.predicate
  
  always_comb begin : comb_logic
    __tmpvar__comb_logic_in0 = 3'd0;
    __tmpvar__comb_logic_in1 = 3'd0;
    for ( int i = 0; i < __const__num_inports_at_comb_logic; i += 1 )
      recv_in__rdy[i] = 1'd0;
    recv_predicate__rdy = 1'd0;
    if ( recv_opt__en ) begin
      if ( recv_opt__msg.fu_in[0] != 3'd0 ) begin
        __tmpvar__comb_logic_in0 = recv_opt__msg.fu_in[0] - 3'd1;
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd1;
      end
      if ( recv_opt__msg.fu_in[1] != 3'd0 ) begin
        __tmpvar__comb_logic_in1 = recv_opt__msg.fu_in[1] - 3'd1;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd1;
      end
      if ( recv_opt__msg.predicate == 1'd1 ) begin
        recv_predicate__rdy = 1'd1;
      end
    end
    send_out__msg[0].predicate = recv_in__msg[__tmpvar__comb_logic_in0].predicate && recv_in__msg[__tmpvar__comb_logic_in1].predicate;
    for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
      send_out__en[j] = recv_opt__en;
    if ( recv_opt__msg.ctrl == __const__OPT_ADD ) begin
      send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in0].payload + recv_in__msg[__tmpvar__comb_logic_in1].payload;
      send_out__msg[0].predicate = recv_in__msg[__tmpvar__comb_logic_in0].predicate && recv_in__msg[__tmpvar__comb_logic_in1].predicate;
      if ( recv_opt__en && ( ( recv_in_count[__tmpvar__comb_logic_in0] == 2'd0 ) || ( recv_in_count[__tmpvar__comb_logic_in1] == 2'd0 ) ) ) begin
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd0;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd0;
        send_out__msg[0].predicate = 1'd0;
      end
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_ADD_CONST ) begin
      send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in0].payload + recv_const__msg.payload;
      send_out__msg[0].predicate = recv_in__msg[__tmpvar__comb_logic_in0].predicate;
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_INC ) begin
      send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in0].payload + const_one.payload;
      send_out__msg[0].predicate = recv_in__msg[__tmpvar__comb_logic_in0].predicate;
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_SUB ) begin
      send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in0].payload - recv_in__msg[__tmpvar__comb_logic_in1].payload;
      send_out__msg[0].predicate = recv_in__msg[__tmpvar__comb_logic_in0].predicate;
      if ( recv_opt__en && ( ( recv_in_count[__tmpvar__comb_logic_in0] == 2'd0 ) || ( recv_in_count[__tmpvar__comb_logic_in1] == 2'd0 ) ) ) begin
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd0;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd0;
        send_out__msg[0].predicate = 1'd0;
      end
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_PAS ) begin
      send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in0].payload;
      send_out__msg[0].predicate = recv_in__msg[__tmpvar__comb_logic_in0].predicate;
    end
    else
      for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
        send_out__en[j] = 1'd0;
    if ( recv_opt__msg.predicate == 1'd1 ) begin
      send_out__msg[0].predicate = send_out__msg[0].predicate && recv_predicate__msg.predicate;
    end
  end

  // PyMTL Update Block Source
  // At ../../VectorCGRA/fu/basic/Fu.py:49
  // @s.update
  // def update_mem():
  //   s.to_mem_waddr.en    = b1( 0 )
  //   s.to_mem_wdata.en    = b1( 0 )
  //   s.to_mem_wdata.msg   = s.const_zero
  //   s.to_mem_waddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.en    = b1( 0 )
  //   s.from_mem_rdata.rdy = b1( 0 )
  
  always_comb begin : update_mem
    to_mem_waddr__en = 1'd0;
    to_mem_wdata__en = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 3'd0;
    to_mem_raddr__msg = 3'd0;
    to_mem_raddr__en = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At ../../VectorCGRA/fu/basic/Fu.py:43
  // @s.update
  // def update_signal():
  //   for j in range( num_outports ):
  //     s.recv_const.rdy = s.send_out[j].rdy or s.recv_const.rdy
  //     s.recv_opt.rdy = s.send_out[j].rdy or s.recv_opt.rdy
  
  always_comb begin : update_signal
    for ( int j = 0; j < __const__num_outports_at_update_signal; j += 1 ) begin
      recv_const__rdy = send_out__rdy[j] || recv_const__rdy;
      recv_opt__rdy = send_out__rdy[j] || recv_opt__rdy;
    end
  end

endmodule


// PyMTL Component CompRTL Definition
// Full name: CompRTL__DataType_CGRAData_32_1_1__PredicateType_CGRAData_1_1__CtrlType_CGRAConfig_6_4_8_8__num_inports_4__num_outports_2__data_mem_size_8
// At ../../VectorCGRA/fu/single/CompRTL.py

module CompRTL__a050676efb0a4b04
(
  input logic [0:0] clk,
  input logic [0:0] initial_carry_in,
  output logic [0:0] initial_carry_out,
  input logic [1:0] recv_in_count [0:3],
  input logic [0:0] reset,
  input logic [0:0] from_mem_rdata__en,
  input CGRAData_32_1_1 from_mem_rdata__msg,
  output logic [0:0] from_mem_rdata__rdy,
  input logic [0:0] recv_const__en,
  input CGRAData_32_1_1 recv_const__msg,
  output logic [0:0] recv_const__rdy,
  input logic [0:0] recv_in__en [0:3],
  input CGRAData_32_1_1 recv_in__msg [0:3],
  output logic [0:0] recv_in__rdy [0:3],
  input logic [0:0] recv_opt__en,
  input CGRAConfig_6_4_8_8 recv_opt__msg,
  output logic [0:0] recv_opt__rdy,
  input logic [0:0] recv_predicate__en,
  input CGRAData_1_1 recv_predicate__msg,
  output logic [0:0] recv_predicate__rdy,
  output logic [0:0] send_out__en [0:1],
  output CGRAData_32_1_1 send_out__msg [0:1],
  input logic [0:0] send_out__rdy [0:1],
  output logic [0:0] to_mem_raddr__en,
  output logic [2:0] to_mem_raddr__msg,
  input logic [0:0] to_mem_raddr__rdy,
  output logic [0:0] to_mem_waddr__en,
  output logic [2:0] to_mem_waddr__msg,
  input logic [0:0] to_mem_waddr__rdy,
  output logic [0:0] to_mem_wdata__en,
  output CGRAData_32_1_1 to_mem_wdata__msg,
  input logic [0:0] to_mem_wdata__rdy
);
  localparam CGRAData_32_1_1 const_one = { 32'd1, 1'd0, 1'd0 };
  localparam CGRAData_32_1_1 const_zero = { 32'd0, 1'd0, 1'd0 };
  localparam logic [31:0] __const__num_outports_at_update_signal = 32'd2;
  localparam logic [31:0] __const__num_inports_at_read_reg = 32'd4;
  localparam logic [31:0] __const__num_outports_at_read_reg = 32'd2;
  localparam logic [5:0] __const__OPT_EQ = 6'd14;
  localparam logic [5:0] __const__OPT_EQ_CONST = 6'd33;
  localparam logic [5:0] __const__OPT_LE = 6'd15;
  logic [2:0] __tmpvar__read_reg_in0 ;
  logic [2:0] __tmpvar__read_reg_in1 ;
  logic [0:0] __tmpvar__read_reg_predicate ;

  // PyMTL Update Block Source
  // At ../../VectorCGRA/fu/single/CompRTL.py:34
  // @s.update
  // def read_reg():
  // 
  //   # For pick input register
  //   in0 = FuInType( 0 )
  //   in1 = FuInType( 0 ) 
  //   for i in range( num_inports ):
  //     s.recv_in[i].rdy = b1( 0 )
  //   s.recv_predicate.rdy = b1( 0 )
  //   if s.recv_opt.en:
  //     if s.recv_opt.msg.fu_in[0] != FuInType( 0 ):
  //       in0 = s.recv_opt.msg.fu_in[0] - FuInType( 1 )
  //       s.recv_in[in0].rdy = b1( 1 )
  //     if s.recv_opt.msg.fu_in[1] != FuInType( 0 ):
  //       in1 = s.recv_opt.msg.fu_in[1] - FuInType( 1 )
  //       s.recv_in[in1].rdy = b1( 1 )
  //     if s.recv_opt.msg.predicate == b1( 1 ):
  //       s.recv_predicate.rdy = b1( 1 )
  // 
  //   predicate = s.recv_in[in0].msg.predicate & s.recv_in[in1].msg.predicate
  //   s.send_out[0].msg = s.const_one
  // 
  //   for j in range( num_outports ):
  //     s.send_out[j].en = s.recv_opt.en
  // 
  //   if s.recv_opt.msg.ctrl == OPT_EQ:
  //     if s.recv_in[in0].msg.payload == s.recv_in[in1].msg.payload:
  //       s.send_out[0].msg = s.const_one
  //       s.send_out[0].msg.predicate = predicate
  //     else:
  //       s.send_out[0].msg = s.const_zero
  //       s.send_out[0].msg.predicate = predicate
  //     if s.recv_opt.en and ( s.recv_in_count[in0] == CountType( 0 ) or\
  //                            s.recv_in_count[in1] == CountType( 0 ) ):
  //       s.recv_in[in0].rdy = b1( 0 )
  //       s.recv_in[in1].rdy = b1( 0 )
  //       s.send_out[0].msg.predicate = b1( 0 )
  // 
  //   elif s.recv_opt.msg.ctrl == OPT_EQ_CONST:
  //     if s.recv_in[in0].msg.payload == s.recv_const.msg.payload:
  //       s.send_out[0].msg = s.const_one
  //       s.send_out[0].msg.predicate = b1( 1 )
  //     else:
  //       s.send_out[0].msg = s.const_zero
  //       s.send_out[0].msg.predicate = b1( 1 )
  // 
  //   elif s.recv_opt.msg.ctrl == OPT_LE:
  //     if s.recv_in[in0].msg.payload < s.recv_in[in1].msg.payload:
  //       s.send_out[0].msg = s.const_one
  //       s.send_out[0].msg.predicate = predicate
  //     else:
  //       s.send_out[0].msg = s.const_zero
  //       s.send_out[0].msg.predicate = predicate
  //     if s.recv_opt.en and ( s.recv_in_count[in0] == CountType( 0 ) or\
  //                            s.recv_in_count[in1] == CountType( 0 ) ):
  //       s.recv_in[in0].rdy = b1( 0 )
  //       s.recv_in[in1].rdy = b1( 0 )
  // 
  //   else:
  //     for j in range( num_outports ):
  //       s.send_out[j].en = b1( 0 )
  // 
  //   if s.recv_opt.msg.predicate == b1( 1 ):
  //     s.send_out[0].msg.predicate = s.send_out[0].msg.predicate and\
  //                                   s.recv_predicate.msg.predicate
  
  always_comb begin : read_reg
    __tmpvar__read_reg_in0 = 3'd0;
    __tmpvar__read_reg_in1 = 3'd0;
    for ( int i = 0; i < __const__num_inports_at_read_reg; i += 1 )
      recv_in__rdy[i] = 1'd0;
    recv_predicate__rdy = 1'd0;
    if ( recv_opt__en ) begin
      if ( recv_opt__msg.fu_in[0] != 3'd0 ) begin
        __tmpvar__read_reg_in0 = recv_opt__msg.fu_in[0] - 3'd1;
        recv_in__rdy[__tmpvar__read_reg_in0] = 1'd1;
      end
      if ( recv_opt__msg.fu_in[1] != 3'd0 ) begin
        __tmpvar__read_reg_in1 = recv_opt__msg.fu_in[1] - 3'd1;
        recv_in__rdy[__tmpvar__read_reg_in1] = 1'd1;
      end
      if ( recv_opt__msg.predicate == 1'd1 ) begin
        recv_predicate__rdy = 1'd1;
      end
    end
    __tmpvar__read_reg_predicate = recv_in__msg[__tmpvar__read_reg_in0].predicate & recv_in__msg[__tmpvar__read_reg_in1].predicate;
    send_out__msg[0] = const_one;
    for ( int j = 0; j < __const__num_outports_at_read_reg; j += 1 )
      send_out__en[j] = recv_opt__en;
    if ( recv_opt__msg.ctrl == __const__OPT_EQ ) begin
      if ( recv_in__msg[__tmpvar__read_reg_in0].payload == recv_in__msg[__tmpvar__read_reg_in1].payload ) begin
        send_out__msg[0] = const_one;
        send_out__msg[0].predicate = __tmpvar__read_reg_predicate;
      end
      else begin
        send_out__msg[0] = const_zero;
        send_out__msg[0].predicate = __tmpvar__read_reg_predicate;
      end
      if ( recv_opt__en && ( ( recv_in_count[__tmpvar__read_reg_in0] == 2'd0 ) || ( recv_in_count[__tmpvar__read_reg_in1] == 2'd0 ) ) ) begin
        recv_in__rdy[__tmpvar__read_reg_in0] = 1'd0;
        recv_in__rdy[__tmpvar__read_reg_in1] = 1'd0;
        send_out__msg[0].predicate = 1'd0;
      end
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_EQ_CONST ) begin
      if ( recv_in__msg[__tmpvar__read_reg_in0].payload == recv_const__msg.payload ) begin
        send_out__msg[0] = const_one;
        send_out__msg[0].predicate = 1'd1;
      end
      else begin
        send_out__msg[0] = const_zero;
        send_out__msg[0].predicate = 1'd1;
      end
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_LE ) begin
      if ( recv_in__msg[__tmpvar__read_reg_in0].payload < recv_in__msg[__tmpvar__read_reg_in1].payload ) begin
        send_out__msg[0] = const_one;
        send_out__msg[0].predicate = __tmpvar__read_reg_predicate;
      end
      else begin
        send_out__msg[0] = const_zero;
        send_out__msg[0].predicate = __tmpvar__read_reg_predicate;
      end
      if ( recv_opt__en && ( ( recv_in_count[__tmpvar__read_reg_in0] == 2'd0 ) || ( recv_in_count[__tmpvar__read_reg_in1] == 2'd0 ) ) ) begin
        recv_in__rdy[__tmpvar__read_reg_in0] = 1'd0;
        recv_in__rdy[__tmpvar__read_reg_in1] = 1'd0;
      end
    end
    else
      for ( int j = 0; j < __const__num_outports_at_read_reg; j += 1 )
        send_out__en[j] = 1'd0;
    if ( recv_opt__msg.predicate == 1'd1 ) begin
      send_out__msg[0].predicate = send_out__msg[0].predicate && recv_predicate__msg.predicate;
    end
  end

  // PyMTL Update Block Source
  // At ../../VectorCGRA/fu/basic/Fu.py:49
  // @s.update
  // def update_mem():
  //   s.to_mem_waddr.en    = b1( 0 )
  //   s.to_mem_wdata.en    = b1( 0 )
  //   s.to_mem_wdata.msg   = s.const_zero
  //   s.to_mem_waddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.en    = b1( 0 )
  //   s.from_mem_rdata.rdy = b1( 0 )
  
  always_comb begin : update_mem
    to_mem_waddr__en = 1'd0;
    to_mem_wdata__en = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 3'd0;
    to_mem_raddr__msg = 3'd0;
    to_mem_raddr__en = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At ../../VectorCGRA/fu/basic/Fu.py:43
  // @s.update
  // def update_signal():
  //   for j in range( num_outports ):
  //     s.recv_const.rdy = s.send_out[j].rdy or s.recv_const.rdy
  //     s.recv_opt.rdy = s.send_out[j].rdy or s.recv_opt.rdy
  
  always_comb begin : update_signal
    for ( int j = 0; j < __const__num_outports_at_update_signal; j += 1 ) begin
      recv_const__rdy = send_out__rdy[j] || recv_const__rdy;
      recv_opt__rdy = send_out__rdy[j] || recv_opt__rdy;
    end
  end

endmodule


// PyMTL Component MulRTL Definition
// Full name: MulRTL__DataType_CGRAData_32_1_1__PredicateType_CGRAData_1_1__CtrlType_CGRAConfig_6_4_8_8__num_inports_4__num_outports_2__data_mem_size_8
// At ../../VectorCGRA/fu/single/MulRTL.py

module MulRTL__a050676efb0a4b04
(
  input logic [0:0] clk,
  input logic [0:0] initial_carry_in,
  output logic [0:0] initial_carry_out,
  input logic [1:0] recv_in_count [0:3],
  input logic [0:0] reset,
  input logic [0:0] from_mem_rdata__en,
  input CGRAData_32_1_1 from_mem_rdata__msg,
  output logic [0:0] from_mem_rdata__rdy,
  input logic [0:0] recv_const__en,
  input CGRAData_32_1_1 recv_const__msg,
  output logic [0:0] recv_const__rdy,
  input logic [0:0] recv_in__en [0:3],
  input CGRAData_32_1_1 recv_in__msg [0:3],
  output logic [0:0] recv_in__rdy [0:3],
  input logic [0:0] recv_opt__en,
  input CGRAConfig_6_4_8_8 recv_opt__msg,
  output logic [0:0] recv_opt__rdy,
  input logic [0:0] recv_predicate__en,
  input CGRAData_1_1 recv_predicate__msg,
  output logic [0:0] recv_predicate__rdy,
  output logic [0:0] send_out__en [0:1],
  output CGRAData_32_1_1 send_out__msg [0:1],
  input logic [0:0] send_out__rdy [0:1],
  output logic [0:0] to_mem_raddr__en,
  output logic [2:0] to_mem_raddr__msg,
  input logic [0:0] to_mem_raddr__rdy,
  output logic [0:0] to_mem_waddr__en,
  output logic [2:0] to_mem_waddr__msg,
  input logic [0:0] to_mem_waddr__rdy,
  output logic [0:0] to_mem_wdata__en,
  output CGRAData_32_1_1 to_mem_wdata__msg,
  input logic [0:0] to_mem_wdata__rdy
);
  localparam CGRAData_32_1_1 const_zero = { 32'd0, 1'd0, 1'd0 };
  localparam logic [31:0] __const__num_outports_at_update_signal = 32'd2;
  localparam logic [31:0] __const__num_inports_at_comb_logic = 32'd4;
  localparam logic [31:0] __const__num_outports_at_comb_logic = 32'd2;
  localparam logic [5:0] __const__OPT_MUL = 6'd7;
  localparam logic [5:0] __const__OPT_MUL_CONST = 6'd29;
  localparam logic [5:0] __const__OPT_DIV = 6'd26;
  logic [2:0] __tmpvar__comb_logic_in0 ;
  logic [2:0] __tmpvar__comb_logic_in1 ;

  // PyMTL Update Block Source
  // At ../../VectorCGRA/fu/single/MulRTL.py:28
  // @s.update
  // def comb_logic():
  // 
  //   # For pick input register
  //   in0 = FuInType( 0 )
  //   in1 = FuInType( 0 )
  //   for i in range( num_inports ):
  //     s.recv_in[i].rdy = b1( 0 )
  // 
  //   s.recv_predicate.rdy = b1( 0 )
  // 
  //   if s.recv_opt.en:
  //     if s.recv_opt.msg.fu_in[0] != FuInType( 0 ):
  //       in0 = s.recv_opt.msg.fu_in[0] - FuInType( 1 )
  //       s.recv_in[in0].rdy = b1( 1 )
  //     if s.recv_opt.msg.fu_in[1] != FuInType( 0 ):
  //       in1 = s.recv_opt.msg.fu_in[1] - FuInType( 1 )
  //       s.recv_in[in1].rdy = b1( 1 )
  //     if s.recv_opt.msg.predicate == b1( 1 ):
  //       s.recv_predicate.rdy = b1( 1 )
  // 
  //   s.send_out[0].msg.predicate = s.recv_in[in0].msg.predicate and\
  //                                 s.recv_in[in1].msg.predicate
  // 
  //   for j in range( num_outports ):
  //     s.send_out[j].en = s.recv_opt.en
  //   if s.recv_opt.msg.ctrl == OPT_MUL:
  //     s.send_out[0].msg.payload = s.recv_in[in0].msg.payload * s.recv_in[in1].msg.payload
  //     if s.recv_opt.en and ( s.recv_in_count[in0] == CountType( 0 ) or\
  //                            s.recv_in_count[in1] == CountType( 0 ) ):
  //       s.recv_in[in0].rdy = b1( 0 )
  //       s.recv_in[in1].rdy = b1( 0 )
  //       s.send_out[0].msg.predicate = b1( 0 )
  //   elif s.recv_opt.msg.ctrl == OPT_MUL_CONST:
  //     s.send_out[0].msg.payload = s.recv_in[in0].msg.payload * s.recv_const.msg.payload
  //     s.send_out[0].msg.predicate = s.recv_in[in0].msg.predicate
  //   elif s.recv_opt.msg.ctrl == OPT_DIV:
  //     s.send_out[0].msg.payload = s.recv_in[in0].msg.payload / s.recv_in[in1].msg.payload
  //     if s.recv_opt.en and ( s.recv_in_count[in0] == CountType( 0 ) or\
  //                            s.recv_in_count[in1] == CountType( 0 ) ):
  //       s.recv_in[in0].rdy = b1( 0 )
  //       s.recv_in[in1].rdy = b1( 0 )
  //       s.send_out[0].msg.predicate = b1( 0 )
  //   else:
  //     for j in range( num_outports ):
  //       s.send_out[j].en = b1( 0 )
  // 
  //   if s.recv_opt.msg.predicate == b1( 1 ):
  //     s.send_out[0].msg.predicate = s.send_out[0].msg.predicate and\
  //                                   s.recv_predicate.msg.predicate
  
  always_comb begin : comb_logic
    __tmpvar__comb_logic_in0 = 3'd0;
    __tmpvar__comb_logic_in1 = 3'd0;
    for ( int i = 0; i < __const__num_inports_at_comb_logic; i += 1 )
      recv_in__rdy[i] = 1'd0;
    recv_predicate__rdy = 1'd0;
    if ( recv_opt__en ) begin
      if ( recv_opt__msg.fu_in[0] != 3'd0 ) begin
        __tmpvar__comb_logic_in0 = recv_opt__msg.fu_in[0] - 3'd1;
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd1;
      end
      if ( recv_opt__msg.fu_in[1] != 3'd0 ) begin
        __tmpvar__comb_logic_in1 = recv_opt__msg.fu_in[1] - 3'd1;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd1;
      end
      if ( recv_opt__msg.predicate == 1'd1 ) begin
        recv_predicate__rdy = 1'd1;
      end
    end
    send_out__msg[0].predicate = recv_in__msg[__tmpvar__comb_logic_in0].predicate && recv_in__msg[__tmpvar__comb_logic_in1].predicate;
    for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
      send_out__en[j] = recv_opt__en;
    if ( recv_opt__msg.ctrl == __const__OPT_MUL ) begin
      send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in0].payload * recv_in__msg[__tmpvar__comb_logic_in1].payload;
      if ( recv_opt__en && ( ( recv_in_count[__tmpvar__comb_logic_in0] == 2'd0 ) || ( recv_in_count[__tmpvar__comb_logic_in1] == 2'd0 ) ) ) begin
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd0;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd0;
        send_out__msg[0].predicate = 1'd0;
      end
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_MUL_CONST ) begin
      send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in0].payload * recv_const__msg.payload;
      send_out__msg[0].predicate = recv_in__msg[__tmpvar__comb_logic_in0].predicate;
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_DIV ) begin
      send_out__msg[0].payload = recv_in__msg[__tmpvar__comb_logic_in0].payload / recv_in__msg[__tmpvar__comb_logic_in1].payload;
      if ( recv_opt__en && ( ( recv_in_count[__tmpvar__comb_logic_in0] == 2'd0 ) || ( recv_in_count[__tmpvar__comb_logic_in1] == 2'd0 ) ) ) begin
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd0;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd0;
        send_out__msg[0].predicate = 1'd0;
      end
    end
    else
      for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
        send_out__en[j] = 1'd0;
    if ( recv_opt__msg.predicate == 1'd1 ) begin
      send_out__msg[0].predicate = send_out__msg[0].predicate && recv_predicate__msg.predicate;
    end
  end

  // PyMTL Update Block Source
  // At ../../VectorCGRA/fu/basic/Fu.py:49
  // @s.update
  // def update_mem():
  //   s.to_mem_waddr.en    = b1( 0 )
  //   s.to_mem_wdata.en    = b1( 0 )
  //   s.to_mem_wdata.msg   = s.const_zero
  //   s.to_mem_waddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.en    = b1( 0 )
  //   s.from_mem_rdata.rdy = b1( 0 )
  
  always_comb begin : update_mem
    to_mem_waddr__en = 1'd0;
    to_mem_wdata__en = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 3'd0;
    to_mem_raddr__msg = 3'd0;
    to_mem_raddr__en = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At ../../VectorCGRA/fu/basic/Fu.py:43
  // @s.update
  // def update_signal():
  //   for j in range( num_outports ):
  //     s.recv_const.rdy = s.send_out[j].rdy or s.recv_const.rdy
  //     s.recv_opt.rdy = s.send_out[j].rdy or s.recv_opt.rdy
  
  always_comb begin : update_signal
    for ( int j = 0; j < __const__num_outports_at_update_signal; j += 1 ) begin
      recv_const__rdy = send_out__rdy[j] || recv_const__rdy;
      recv_opt__rdy = send_out__rdy[j] || recv_opt__rdy;
    end
  end

endmodule


// PyMTL Component BranchRTL Definition
// Full name: BranchRTL__DataType_CGRAData_32_1_1__PredicateType_CGRAData_1_1__CtrlType_CGRAConfig_6_4_8_8__num_inports_4__num_outports_2__data_mem_size_8
// At ../../VectorCGRA/fu/single/BranchRTL.py

module BranchRTL__a050676efb0a4b04
(
  input logic [0:0] clk,
  input logic [0:0] initial_carry_in,
  output logic [0:0] initial_carry_out,
  input logic [1:0] recv_in_count [0:3],
  input logic [0:0] reset,
  input logic [0:0] from_mem_rdata__en,
  input CGRAData_32_1_1 from_mem_rdata__msg,
  output logic [0:0] from_mem_rdata__rdy,
  input logic [0:0] recv_const__en,
  input CGRAData_32_1_1 recv_const__msg,
  output logic [0:0] recv_const__rdy,
  input logic [0:0] recv_in__en [0:3],
  input CGRAData_32_1_1 recv_in__msg [0:3],
  output logic [0:0] recv_in__rdy [0:3],
  input logic [0:0] recv_opt__en,
  input CGRAConfig_6_4_8_8 recv_opt__msg,
  output logic [0:0] recv_opt__rdy,
  input logic [0:0] recv_predicate__en,
  input CGRAData_1_1 recv_predicate__msg,
  output logic [0:0] recv_predicate__rdy,
  output logic [0:0] send_out__en [0:1],
  output CGRAData_32_1_1 send_out__msg [0:1],
  input logic [0:0] send_out__rdy [0:1],
  output logic [0:0] to_mem_raddr__en,
  output logic [2:0] to_mem_raddr__msg,
  input logic [0:0] to_mem_raddr__rdy,
  output logic [0:0] to_mem_waddr__en,
  output logic [2:0] to_mem_waddr__msg,
  input logic [0:0] to_mem_waddr__rdy,
  output logic [0:0] to_mem_wdata__en,
  output CGRAData_32_1_1 to_mem_wdata__msg,
  input logic [0:0] to_mem_wdata__rdy
);
  localparam CGRAData_32_1_1 const_zero = { 32'd0, 1'd0, 1'd0 };
  localparam logic [31:0] __const__num_outports_at_update_signal = 32'd2;
  localparam logic [31:0] __const__num_inports_at_comb_logic = 32'd4;
  localparam logic [31:0] __const__num_outports_at_comb_logic = 32'd2;
  localparam logic [5:0] __const__OPT_BRH = 6'd16;
  localparam logic [5:0] __const__OPT_BRH_START = 6'd34;
  logic [0:0] first ;
  logic [2:0] __tmpvar__comb_logic_in0 ;

  // PyMTL Update Block Source
  // At ../../VectorCGRA/fu/single/BranchRTL.py:32
  //     @s.update
  //     def comb_logic():
  // 
  //       # For pick input register
  //       in0 = FuInType( 0 )
  //       # in1 = FuInType( 0 )
  //       for i in range( num_inports ):
  //         s.recv_in[i].rdy = b1( 0 )
  // 
  //       s.recv_predicate.rdy = b1( 0 )
  // 
  //       if s.recv_opt.en:
  //         if s.recv_opt.msg.fu_in[0] != FuInType( 0 ):
  //           in0 = s.recv_opt.msg.fu_in[0] - FuInType( 1 )
  //           s.recv_in[in0].rdy = b1( 1 )
  // #        if s.recv_opt.msg.fu_in[1] != FuInType( 0 ):
  // #          in1 = s.recv_opt.msg.fu_in[1] - FuInType( 1 )
  // #          s.recv_in[in1].rdy = b1( 1 )
  // 
  //         if s.recv_opt.msg.predicate == b1( 1 ):
  //           s.recv_predicate.rdy = b1( 1 )
  // 
  // 
  //       for j in range( num_outports ):
  //         s.send_out[j].en = s.recv_opt.en
  //       if s.recv_opt.msg.ctrl == OPT_BRH:
  //         # Branch is only used to set predication rather than delivering value.
  //         s.send_out[0].msg = DataType(ZeroType( 0 ), b1( 0 ), b1( 0 ) )
  //         s.send_out[1].msg = DataType(ZeroType( 0 ), b1( 0 ), b1( 0 ) )
  //         if s.recv_in[in0].msg.payload == s.const_zero.payload:
  //           s.send_out[0].msg.predicate = Bits1( 1 )
  //           s.send_out[1].msg.predicate = Bits1( 0 )
  //         else:
  //           s.send_out[0].msg.predicate = Bits1( 0 )
  //           s.send_out[1].msg.predicate = Bits1( 1 )
  //       elif s.recv_opt.msg.ctrl == OPT_BRH_START:
  //         s.send_out[0].msg = DataType(ZeroType( 0 ), b1( 0 ), b1( 0 ) )
  //         s.send_out[1].msg = DataType(ZeroType( 0 ), b1( 0 ), b1( 0 ) )
  //         if s.first == b1( 1 ):
  //           s.send_out[0].msg.predicate = Bits1( 1 )
  //           s.send_out[1].msg.predicate = Bits1( 0 )
  //         else:
  //           s.send_out[0].msg.predicate = Bits1( 0 )
  //           s.send_out[1].msg.predicate = Bits1( 1 )
  // 
  //       else:
  //         for j in range( num_outports ):
  //           s.send_out[j].en = b1( 0 )
  // 
  //       if s.recv_opt.msg.predicate == b1( 1 ) and s.recv_opt.msg.ctrl != OPT_BRH_START:
  //         # The operation executed on the first cycle gets no input predicate.
  //         s.send_out[0].msg.predicate = s.send_out[0].msg.predicate and\
  //                                        s.recv_predicate.msg.predicate
  //         s.send_out[1].msg.predicate = s.send_out[1].msg.predicate and\
  //                                       s.recv_predicate.msg.predicate
  
  always_comb begin : comb_logic
    __tmpvar__comb_logic_in0 = 3'd0;
    for ( int i = 0; i < __const__num_inports_at_comb_logic; i += 1 )
      recv_in__rdy[i] = 1'd0;
    recv_predicate__rdy = 1'd0;
    if ( recv_opt__en ) begin
      if ( recv_opt__msg.fu_in[0] != 3'd0 ) begin
        __tmpvar__comb_logic_in0 = recv_opt__msg.fu_in[0] - 3'd1;
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd1;
      end
      if ( recv_opt__msg.predicate == 1'd1 ) begin
        recv_predicate__rdy = 1'd1;
      end
    end
    for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
      send_out__en[j] = recv_opt__en;
    if ( recv_opt__msg.ctrl == __const__OPT_BRH ) begin
      send_out__msg[0] = { 32'd0, 1'd0, 1'd0 };
      send_out__msg[1] = { 32'd0, 1'd0, 1'd0 };
      if ( recv_in__msg[__tmpvar__comb_logic_in0].payload == const_zero.payload ) begin
        send_out__msg[0].predicate = 1'd1;
        send_out__msg[1].predicate = 1'd0;
      end
      else begin
        send_out__msg[0].predicate = 1'd0;
        send_out__msg[1].predicate = 1'd1;
      end
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_BRH_START ) begin
      send_out__msg[0] = { 32'd0, 1'd0, 1'd0 };
      send_out__msg[1] = { 32'd0, 1'd0, 1'd0 };
      if ( first == 1'd1 ) begin
        send_out__msg[0].predicate = 1'd1;
        send_out__msg[1].predicate = 1'd0;
      end
      else begin
        send_out__msg[0].predicate = 1'd0;
        send_out__msg[1].predicate = 1'd1;
      end
    end
    else
      for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
        send_out__en[j] = 1'd0;
    if ( ( recv_opt__msg.predicate == 1'd1 ) && ( recv_opt__msg.ctrl != __const__OPT_BRH_START ) ) begin
      send_out__msg[0].predicate = send_out__msg[0].predicate && recv_predicate__msg.predicate;
      send_out__msg[1].predicate = send_out__msg[1].predicate && recv_predicate__msg.predicate;
    end
  end

  // PyMTL Update Block Source
  // At ../../VectorCGRA/fu/basic/Fu.py:49
  // @s.update
  // def update_mem():
  //   s.to_mem_waddr.en    = b1( 0 )
  //   s.to_mem_wdata.en    = b1( 0 )
  //   s.to_mem_wdata.msg   = s.const_zero
  //   s.to_mem_waddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.msg   = AddrType( 0 )
  //   s.to_mem_raddr.en    = b1( 0 )
  //   s.from_mem_rdata.rdy = b1( 0 )
  
  always_comb begin : update_mem
    to_mem_waddr__en = 1'd0;
    to_mem_wdata__en = 1'd0;
    to_mem_wdata__msg = const_zero;
    to_mem_waddr__msg = 3'd0;
    to_mem_raddr__msg = 3'd0;
    to_mem_raddr__en = 1'd0;
    from_mem_rdata__rdy = 1'd0;
  end

  // PyMTL Update Block Source
  // At ../../VectorCGRA/fu/basic/Fu.py:43
  // @s.update
  // def update_signal():
  //   for j in range( num_outports ):
  //     s.recv_const.rdy = s.send_out[j].rdy or s.recv_const.rdy
  //     s.recv_opt.rdy = s.send_out[j].rdy or s.recv_opt.rdy
  
  always_comb begin : update_signal
    for ( int j = 0; j < __const__num_outports_at_update_signal; j += 1 ) begin
      recv_const__rdy = send_out__rdy[j] || recv_const__rdy;
      recv_opt__rdy = send_out__rdy[j] || recv_opt__rdy;
    end
  end

  // PyMTL Update Block Source
  // At ../../VectorCGRA/fu/single/BranchRTL.py:90
  // @s.update_ff
  // def br_start_once():
  //   if s.reset:
  //     s.first <<= b1( 1 )
  //   if s.recv_opt.msg.ctrl == OPT_BRH_START:
  //     s.first <<= b1( 0 )
  
  always_ff @(posedge clk) begin : br_start_once
    if ( reset ) begin
      first <= 1'd1;
    end
    if ( recv_opt__msg.ctrl == __const__OPT_BRH_START ) begin
      first <= 1'd0;
    end
  end

endmodule


// PyMTL Component MemUnitRTL Definition
// Full name: MemUnitRTL__DataType_CGRAData_32_1_1__PredicateType_CGRAData_1_1__CtrlType_CGRAConfig_6_4_8_8__num_inports_4__num_outports_2__data_mem_size_8
// At ../../VectorCGRA/fu/single/MemUnitRTL.py

module MemUnitRTL__a050676efb0a4b04
(
  input logic [0:0] clk,
  input logic [0:0] initial_carry_in,
  output logic [0:0] initial_carry_out,
  input logic [1:0] recv_in_count [0:3],
  input logic [0:0] reset,
  input logic [0:0] from_mem_rdata__en,
  input CGRAData_32_1_1 from_mem_rdata__msg,
  output logic [0:0] from_mem_rdata__rdy,
  input logic [0:0] recv_const__en,
  input CGRAData_32_1_1 recv_const__msg,
  output logic [0:0] recv_const__rdy,
  input logic [0:0] recv_in__en [0:3],
  input CGRAData_32_1_1 recv_in__msg [0:3],
  output logic [0:0] recv_in__rdy [0:3],
  input logic [0:0] recv_opt__en,
  input CGRAConfig_6_4_8_8 recv_opt__msg,
  output logic [0:0] recv_opt__rdy,
  input logic [0:0] recv_predicate__en,
  input CGRAData_1_1 recv_predicate__msg,
  output logic [0:0] recv_predicate__rdy,
  output logic [0:0] send_out__en [0:1],
  output CGRAData_32_1_1 send_out__msg [0:1],
  input logic [0:0] send_out__rdy [0:1],
  output logic [0:0] to_mem_raddr__en,
  output logic [2:0] to_mem_raddr__msg,
  input logic [0:0] to_mem_raddr__rdy,
  output logic [0:0] to_mem_waddr__en,
  output logic [2:0] to_mem_waddr__msg,
  input logic [0:0] to_mem_waddr__rdy,
  output logic [0:0] to_mem_wdata__en,
  output CGRAData_32_1_1 to_mem_wdata__msg,
  input logic [0:0] to_mem_wdata__rdy
);
  localparam logic [31:0] __const__num_inports_at_comb_logic = 32'd4;
  localparam logic [31:0] __const__num_outports_at_comb_logic = 32'd2;
  localparam logic [5:0] __const__OPT_LD = 6'd12;
  localparam logic [5:0] __const__OPT_LD_CONST = 6'd28;
  localparam logic [5:0] __const__OPT_STR = 6'd13;
  logic [2:0] __tmpvar__comb_logic_in0 ;
  logic [2:0] __tmpvar__comb_logic_in1 ;

  // PyMTL Update Block Source
  // At ../../VectorCGRA/fu/single/MemUnitRTL.py:45
  // @s.update
  // def comb_logic():
  // 
  //   # For pick input register
  //   in0 = FuInType( 0 )
  //   in1 = FuInType( 0 )
  //   for i in range( num_inports ):
  //     s.recv_in[i].rdy = b1( 0 )
  // 
  //   s.recv_predicate.rdy = b1( 0 )
  // 
  //   if s.recv_opt.en:
  //     if s.recv_opt.msg.fu_in[0] != FuInType( 0 ):
  //       in0 = s.recv_opt.msg.fu_in[0] - FuInType( 1 )
  //       s.recv_in[in0].rdy = b1( 1 )
  //     if s.recv_opt.msg.fu_in[1] != FuInType( 0 ):
  //       in1 = s.recv_opt.msg.fu_in[1] - FuInType( 1 )
  //       s.recv_in[in1].rdy = b1( 1 )
  //     if s.recv_opt.msg.predicate == b1( 1 ):
  //       s.recv_predicate.rdy = b1( 1 )
  // 
  //   for j in range( num_outports ):
  //     s.recv_const.rdy = s.send_out[j].rdy or s.recv_const.rdy
  // 
  //   for j in range( num_outports ):
  //     s.recv_opt.rdy = s.send_out[j].rdy or s.recv_opt.rdy
  // 
  //   for j in range( num_outports ):
  //     for i in range( num_inports ):
  //       s.send_out[j].en = s.recv_in[i].en or s.send_out[j].en
  //     s.send_out[j].en = s.send_out[j].en and s.recv_opt.en
  // 
  //   s.send_out[0].msg = s.from_mem_rdata.msg
  //   s.to_mem_waddr.en = b1( 0 )
  //   s.to_mem_wdata.en = b1( 0 )
  //   if s.recv_opt.msg.ctrl == OPT_LD:
  //     s.recv_in[in0].rdy     = s.to_mem_raddr.rdy
  //     s.recv_in[in1].rdy     = s.from_mem_rdata.rdy
  //     s.to_mem_raddr.msg   = AddrType( s.recv_in[in0].msg.payload )
  //     s.to_mem_raddr.en    = s.recv_in[in0].en
  //     s.from_mem_rdata.rdy = s.send_out[0].rdy
  //     s.send_out[0].msg    = s.from_mem_rdata.msg
  //     s.send_out[0].en     = s.recv_opt.en
  //     s.send_out[0].msg.predicate = s.recv_in[in0].msg.predicate
  // 
  //   elif s.recv_opt.msg.ctrl == OPT_LD_CONST:
  //     for i in range( num_inports):
  //       s.recv_in[i].rdy = b1( 0 )
  //     s.recv_const.rdy     = s.to_mem_raddr.rdy
  //     s.to_mem_raddr.msg   = AddrType( s.recv_const.msg.payload )
  //     s.to_mem_raddr.en    = s.recv_const.en
  //     s.from_mem_rdata.rdy = s.send_out[0].rdy
  //     s.send_out[0].msg    = s.from_mem_rdata.msg
  //     s.send_out[0].en     = s.recv_opt.en
  //     # Const's predicate will always be true.
  //     s.send_out[0].msg.predicate = b1( 1 )
  // 
  //   elif s.recv_opt.msg.ctrl == OPT_STR:
  //     s.send_out[0].en   = s.from_mem_rdata.en and s.recv_in[in0].en and s.recv_in[in1].en
  //     s.recv_in[in0].rdy   = s.to_mem_waddr.rdy
  //     s.recv_in[in1].rdy   = s.to_mem_wdata.rdy
  //     s.to_mem_waddr.msg = AddrType( s.recv_in[0].msg.payload )
  //     s.to_mem_waddr.en  = s.recv_in[in0].en
  //     s.to_mem_wdata.msg = s.recv_in[in1].msg
  //     s.to_mem_wdata.en  = s.recv_in[in1].en
  //     s.send_out[0].en   = b1( 0 )
  //     s.send_out[0].msg  = s.from_mem_rdata.msg
  //     s.send_out[0].msg.predicate = s.recv_in[in0].msg.predicate and\
  //                                   s.recv_in[in1].msg.predicate
  //     if s.recv_opt.en and ( s.recv_in_count[in0] == CountType( 0 ) or\
  //                            s.recv_in_count[in1] == CountType( 0 ) ):
  //       s.recv_in[in0].rdy = b1( 0 )
  //       s.recv_in[in1].rdy = b1( 0 )
  //       s.send_out[0].msg.predicate = b1( 0 )
  // 
  //   else:
  //     for j in range( num_outports ):
  //       s.send_out[j].en = b1( 0 )
  // 
  //   if s.recv_opt.msg.predicate == b1( 1 ):
  //     s.send_out[0].msg.predicate = s.send_out[0].msg.predicate and\
  //                                   s.recv_predicate.msg.predicate
  
  always_comb begin : comb_logic
    __tmpvar__comb_logic_in0 = 3'd0;
    __tmpvar__comb_logic_in1 = 3'd0;
    for ( int i = 0; i < __const__num_inports_at_comb_logic; i += 1 )
      recv_in__rdy[i] = 1'd0;
    recv_predicate__rdy = 1'd0;
    if ( recv_opt__en ) begin
      if ( recv_opt__msg.fu_in[0] != 3'd0 ) begin
        __tmpvar__comb_logic_in0 = recv_opt__msg.fu_in[0] - 3'd1;
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd1;
      end
      if ( recv_opt__msg.fu_in[1] != 3'd0 ) begin
        __tmpvar__comb_logic_in1 = recv_opt__msg.fu_in[1] - 3'd1;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd1;
      end
      if ( recv_opt__msg.predicate == 1'd1 ) begin
        recv_predicate__rdy = 1'd1;
      end
    end
    for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
      recv_const__rdy = send_out__rdy[j] || recv_const__rdy;
    for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
      recv_opt__rdy = send_out__rdy[j] || recv_opt__rdy;
    for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 ) begin
      for ( int i = 0; i < __const__num_inports_at_comb_logic; i += 1 )
        send_out__en[j] = recv_in__en[i] || send_out__en[j];
      send_out__en[j] = send_out__en[j] && recv_opt__en;
    end
    send_out__msg[0] = from_mem_rdata__msg;
    to_mem_waddr__en = 1'd0;
    to_mem_wdata__en = 1'd0;
    if ( recv_opt__msg.ctrl == __const__OPT_LD ) begin
      recv_in__rdy[__tmpvar__comb_logic_in0] = to_mem_raddr__rdy;
      recv_in__rdy[__tmpvar__comb_logic_in1] = from_mem_rdata__rdy;
      to_mem_raddr__msg = 3'( recv_in__msg[__tmpvar__comb_logic_in0].payload );
      to_mem_raddr__en = recv_in__en[__tmpvar__comb_logic_in0];
      from_mem_rdata__rdy = send_out__rdy[0];
      send_out__msg[0] = from_mem_rdata__msg;
      send_out__en[0] = recv_opt__en;
      send_out__msg[0].predicate = recv_in__msg[__tmpvar__comb_logic_in0].predicate;
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_LD_CONST ) begin
      for ( int i = 0; i < __const__num_inports_at_comb_logic; i += 1 )
        recv_in__rdy[i] = 1'd0;
      recv_const__rdy = to_mem_raddr__rdy;
      to_mem_raddr__msg = 3'( recv_const__msg.payload );
      to_mem_raddr__en = recv_const__en;
      from_mem_rdata__rdy = send_out__rdy[0];
      send_out__msg[0] = from_mem_rdata__msg;
      send_out__en[0] = recv_opt__en;
      send_out__msg[0].predicate = 1'd1;
    end
    else if ( recv_opt__msg.ctrl == __const__OPT_STR ) begin
      send_out__en[0] = from_mem_rdata__en && recv_in__en[__tmpvar__comb_logic_in0] && recv_in__en[__tmpvar__comb_logic_in1];
      recv_in__rdy[__tmpvar__comb_logic_in0] = to_mem_waddr__rdy;
      recv_in__rdy[__tmpvar__comb_logic_in1] = to_mem_wdata__rdy;
      to_mem_waddr__msg = 3'( recv_in__msg[0].payload );
      to_mem_waddr__en = recv_in__en[__tmpvar__comb_logic_in0];
      to_mem_wdata__msg = recv_in__msg[__tmpvar__comb_logic_in1];
      to_mem_wdata__en = recv_in__en[__tmpvar__comb_logic_in1];
      send_out__en[0] = 1'd0;
      send_out__msg[0] = from_mem_rdata__msg;
      send_out__msg[0].predicate = recv_in__msg[__tmpvar__comb_logic_in0].predicate && recv_in__msg[__tmpvar__comb_logic_in1].predicate;
      if ( recv_opt__en && ( ( recv_in_count[__tmpvar__comb_logic_in0] == 2'd0 ) || ( recv_in_count[__tmpvar__comb_logic_in1] == 2'd0 ) ) ) begin
        recv_in__rdy[__tmpvar__comb_logic_in0] = 1'd0;
        recv_in__rdy[__tmpvar__comb_logic_in1] = 1'd0;
        send_out__msg[0].predicate = 1'd0;
      end
    end
    else
      for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
        send_out__en[j] = 1'd0;
    if ( recv_opt__msg.predicate == 1'd1 ) begin
      send_out__msg[0].predicate = send_out__msg[0].predicate && recv_predicate__msg.predicate;
    end
  end

endmodule


// PyMTL Component FlexibleFuRTL Definition
// Full name: FlexibleFuRTL__DataType_CGRAData_32_1_1__PredicateType_CGRAData_1_1__CtrlType_CGRAConfig_6_4_8_8__num_inports_4__num_outports_2__data_mem_size_8__FuList_[<class 'VectorCGRA.fu.single.PhiRTL.PhiRTL'>, <class 'VectorCGRA.fu.single.AdderRTL.AdderRTL'>, <class 'VectorCGRA.fu.single.CompRTL.CompRTL'>, <class 'VectorCGRA.fu.single.MulRTL.MulRTL'>, <class 'VectorCGRA.fu.single.BranchRTL.BranchRTL'>, <class 'VectorCGRA.fu.single.MemUnitRTL.MemUnitRTL'>]
// At ../../VectorCGRA/fu/flexible/FlexibleFuRTL.py

module FlexibleFuRTL__7ccad8d3ed73c188
(
  input logic [0:0] clk,
  input logic [1:0] recv_in_count [0:3],
  input logic [0:0] reset,
  input logic [0:0] from_mem_rdata__en [0:5],
  input CGRAData_32_1_1 from_mem_rdata__msg [0:5],
  output logic [0:0] from_mem_rdata__rdy [0:5],
  input logic [0:0] recv_const__en,
  input CGRAData_32_1_1 recv_const__msg,
  output logic [0:0] recv_const__rdy,
  input logic [0:0] recv_in__en [0:3],
  input CGRAData_32_1_1 recv_in__msg [0:3],
  output logic [0:0] recv_in__rdy [0:3],
  input logic [0:0] recv_opt__en,
  input CGRAConfig_6_4_8_8 recv_opt__msg,
  output logic [0:0] recv_opt__rdy,
  input logic [0:0] recv_predicate__en,
  input CGRAData_1_1 recv_predicate__msg,
  output logic [0:0] recv_predicate__rdy,
  output logic [0:0] send_out__en [0:1],
  output CGRAData_32_1_1 send_out__msg [0:1],
  input logic [0:0] send_out__rdy [0:1],
  output logic [0:0] to_mem_raddr__en [0:5],
  output logic [2:0] to_mem_raddr__msg [0:5],
  input logic [0:0] to_mem_raddr__rdy [0:5],
  output logic [0:0] to_mem_waddr__en [0:5],
  output logic [2:0] to_mem_waddr__msg [0:5],
  input logic [0:0] to_mem_waddr__rdy [0:5],
  output logic [0:0] to_mem_wdata__en [0:5],
  output CGRAData_32_1_1 to_mem_wdata__msg [0:5],
  input logic [0:0] to_mem_wdata__rdy [0:5]
);
  localparam logic [31:0] fu_list_size = 32'd6;
  localparam logic [31:0] __const__num_outports_at_comb_logic = 32'd2;
  localparam logic [31:0] __const__num_inports_at_comb_logic = 32'd4;
  //-------------------------------------------------------------
  // Component fu[0:5]
  //-------------------------------------------------------------

  logic [0:0] fu__clk [0:5] ;
  logic [0:0] fu__initial_carry_in [0:5] ;
  logic [0:0] fu__initial_carry_out [0:5] ;
  logic [1:0] fu__recv_in_count [0:5][0:3] ;
  logic [0:0] fu__reset [0:5] ;
  logic [0:0] fu__from_mem_rdata__en [0:5] ;
  CGRAData_32_1_1 fu__from_mem_rdata__msg [0:5] ;
  logic [0:0] fu__from_mem_rdata__rdy [0:5] ;
  logic [0:0] fu__recv_const__en [0:5] ;
  CGRAData_32_1_1 fu__recv_const__msg [0:5] ;
  logic [0:0] fu__recv_const__rdy [0:5] ;
  logic [0:0] fu__recv_in__en [0:5][0:3] ;
  CGRAData_32_1_1 fu__recv_in__msg [0:5][0:3] ;
  logic [0:0] fu__recv_in__rdy [0:5][0:3] ;
  logic [0:0] fu__recv_opt__en [0:5] ;
  CGRAConfig_6_4_8_8 fu__recv_opt__msg [0:5] ;
  logic [0:0] fu__recv_opt__rdy [0:5] ;
  logic [0:0] fu__recv_predicate__en [0:5] ;
  CGRAData_1_1 fu__recv_predicate__msg [0:5] ;
  logic [0:0] fu__recv_predicate__rdy [0:5] ;
  logic [0:0] fu__send_out__en [0:5][0:1] ;
  CGRAData_32_1_1 fu__send_out__msg [0:5][0:1] ;
  logic [0:0] fu__send_out__rdy [0:5][0:1] ;
  logic [0:0] fu__to_mem_raddr__en [0:5] ;
  logic [2:0] fu__to_mem_raddr__msg [0:5] ;
  logic [0:0] fu__to_mem_raddr__rdy [0:5] ;
  logic [0:0] fu__to_mem_waddr__en [0:5] ;
  logic [2:0] fu__to_mem_waddr__msg [0:5] ;
  logic [0:0] fu__to_mem_waddr__rdy [0:5] ;
  logic [0:0] fu__to_mem_wdata__en [0:5] ;
  CGRAData_32_1_1 fu__to_mem_wdata__msg [0:5] ;
  logic [0:0] fu__to_mem_wdata__rdy [0:5] ;

  PhiRTL__a050676efb0a4b04 fu__0
  (
    .clk( fu__clk[0] ),
    .initial_carry_in( fu__initial_carry_in[0] ),
    .initial_carry_out( fu__initial_carry_out[0] ),
    .recv_in_count( fu__recv_in_count[0] ),
    .reset( fu__reset[0] ),
    .from_mem_rdata__en( fu__from_mem_rdata__en[0] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[0] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[0] ),
    .recv_const__en( fu__recv_const__en[0] ),
    .recv_const__msg( fu__recv_const__msg[0] ),
    .recv_const__rdy( fu__recv_const__rdy[0] ),
    .recv_in__en( fu__recv_in__en[0] ),
    .recv_in__msg( fu__recv_in__msg[0] ),
    .recv_in__rdy( fu__recv_in__rdy[0] ),
    .recv_opt__en( fu__recv_opt__en[0] ),
    .recv_opt__msg( fu__recv_opt__msg[0] ),
    .recv_opt__rdy( fu__recv_opt__rdy[0] ),
    .recv_predicate__en( fu__recv_predicate__en[0] ),
    .recv_predicate__msg( fu__recv_predicate__msg[0] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[0] ),
    .send_out__en( fu__send_out__en[0] ),
    .send_out__msg( fu__send_out__msg[0] ),
    .send_out__rdy( fu__send_out__rdy[0] ),
    .to_mem_raddr__en( fu__to_mem_raddr__en[0] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[0] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[0] ),
    .to_mem_waddr__en( fu__to_mem_waddr__en[0] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[0] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[0] ),
    .to_mem_wdata__en( fu__to_mem_wdata__en[0] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[0] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[0] )
  );

  AdderRTL__a050676efb0a4b04 fu__1
  (
    .clk( fu__clk[1] ),
    .initial_carry_in( fu__initial_carry_in[1] ),
    .initial_carry_out( fu__initial_carry_out[1] ),
    .recv_in_count( fu__recv_in_count[1] ),
    .reset( fu__reset[1] ),
    .from_mem_rdata__en( fu__from_mem_rdata__en[1] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[1] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[1] ),
    .recv_const__en( fu__recv_const__en[1] ),
    .recv_const__msg( fu__recv_const__msg[1] ),
    .recv_const__rdy( fu__recv_const__rdy[1] ),
    .recv_in__en( fu__recv_in__en[1] ),
    .recv_in__msg( fu__recv_in__msg[1] ),
    .recv_in__rdy( fu__recv_in__rdy[1] ),
    .recv_opt__en( fu__recv_opt__en[1] ),
    .recv_opt__msg( fu__recv_opt__msg[1] ),
    .recv_opt__rdy( fu__recv_opt__rdy[1] ),
    .recv_predicate__en( fu__recv_predicate__en[1] ),
    .recv_predicate__msg( fu__recv_predicate__msg[1] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[1] ),
    .send_out__en( fu__send_out__en[1] ),
    .send_out__msg( fu__send_out__msg[1] ),
    .send_out__rdy( fu__send_out__rdy[1] ),
    .to_mem_raddr__en( fu__to_mem_raddr__en[1] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[1] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[1] ),
    .to_mem_waddr__en( fu__to_mem_waddr__en[1] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[1] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[1] ),
    .to_mem_wdata__en( fu__to_mem_wdata__en[1] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[1] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[1] )
  );

  CompRTL__a050676efb0a4b04 fu__2
  (
    .clk( fu__clk[2] ),
    .initial_carry_in( fu__initial_carry_in[2] ),
    .initial_carry_out( fu__initial_carry_out[2] ),
    .recv_in_count( fu__recv_in_count[2] ),
    .reset( fu__reset[2] ),
    .from_mem_rdata__en( fu__from_mem_rdata__en[2] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[2] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[2] ),
    .recv_const__en( fu__recv_const__en[2] ),
    .recv_const__msg( fu__recv_const__msg[2] ),
    .recv_const__rdy( fu__recv_const__rdy[2] ),
    .recv_in__en( fu__recv_in__en[2] ),
    .recv_in__msg( fu__recv_in__msg[2] ),
    .recv_in__rdy( fu__recv_in__rdy[2] ),
    .recv_opt__en( fu__recv_opt__en[2] ),
    .recv_opt__msg( fu__recv_opt__msg[2] ),
    .recv_opt__rdy( fu__recv_opt__rdy[2] ),
    .recv_predicate__en( fu__recv_predicate__en[2] ),
    .recv_predicate__msg( fu__recv_predicate__msg[2] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[2] ),
    .send_out__en( fu__send_out__en[2] ),
    .send_out__msg( fu__send_out__msg[2] ),
    .send_out__rdy( fu__send_out__rdy[2] ),
    .to_mem_raddr__en( fu__to_mem_raddr__en[2] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[2] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[2] ),
    .to_mem_waddr__en( fu__to_mem_waddr__en[2] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[2] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[2] ),
    .to_mem_wdata__en( fu__to_mem_wdata__en[2] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[2] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[2] )
  );

  MulRTL__a050676efb0a4b04 fu__3
  (
    .clk( fu__clk[3] ),
    .initial_carry_in( fu__initial_carry_in[3] ),
    .initial_carry_out( fu__initial_carry_out[3] ),
    .recv_in_count( fu__recv_in_count[3] ),
    .reset( fu__reset[3] ),
    .from_mem_rdata__en( fu__from_mem_rdata__en[3] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[3] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[3] ),
    .recv_const__en( fu__recv_const__en[3] ),
    .recv_const__msg( fu__recv_const__msg[3] ),
    .recv_const__rdy( fu__recv_const__rdy[3] ),
    .recv_in__en( fu__recv_in__en[3] ),
    .recv_in__msg( fu__recv_in__msg[3] ),
    .recv_in__rdy( fu__recv_in__rdy[3] ),
    .recv_opt__en( fu__recv_opt__en[3] ),
    .recv_opt__msg( fu__recv_opt__msg[3] ),
    .recv_opt__rdy( fu__recv_opt__rdy[3] ),
    .recv_predicate__en( fu__recv_predicate__en[3] ),
    .recv_predicate__msg( fu__recv_predicate__msg[3] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[3] ),
    .send_out__en( fu__send_out__en[3] ),
    .send_out__msg( fu__send_out__msg[3] ),
    .send_out__rdy( fu__send_out__rdy[3] ),
    .to_mem_raddr__en( fu__to_mem_raddr__en[3] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[3] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[3] ),
    .to_mem_waddr__en( fu__to_mem_waddr__en[3] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[3] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[3] ),
    .to_mem_wdata__en( fu__to_mem_wdata__en[3] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[3] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[3] )
  );

  BranchRTL__a050676efb0a4b04 fu__4
  (
    .clk( fu__clk[4] ),
    .initial_carry_in( fu__initial_carry_in[4] ),
    .initial_carry_out( fu__initial_carry_out[4] ),
    .recv_in_count( fu__recv_in_count[4] ),
    .reset( fu__reset[4] ),
    .from_mem_rdata__en( fu__from_mem_rdata__en[4] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[4] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[4] ),
    .recv_const__en( fu__recv_const__en[4] ),
    .recv_const__msg( fu__recv_const__msg[4] ),
    .recv_const__rdy( fu__recv_const__rdy[4] ),
    .recv_in__en( fu__recv_in__en[4] ),
    .recv_in__msg( fu__recv_in__msg[4] ),
    .recv_in__rdy( fu__recv_in__rdy[4] ),
    .recv_opt__en( fu__recv_opt__en[4] ),
    .recv_opt__msg( fu__recv_opt__msg[4] ),
    .recv_opt__rdy( fu__recv_opt__rdy[4] ),
    .recv_predicate__en( fu__recv_predicate__en[4] ),
    .recv_predicate__msg( fu__recv_predicate__msg[4] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[4] ),
    .send_out__en( fu__send_out__en[4] ),
    .send_out__msg( fu__send_out__msg[4] ),
    .send_out__rdy( fu__send_out__rdy[4] ),
    .to_mem_raddr__en( fu__to_mem_raddr__en[4] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[4] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[4] ),
    .to_mem_waddr__en( fu__to_mem_waddr__en[4] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[4] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[4] ),
    .to_mem_wdata__en( fu__to_mem_wdata__en[4] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[4] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[4] )
  );

  MemUnitRTL__a050676efb0a4b04 fu__5
  (
    .clk( fu__clk[5] ),
    .initial_carry_in( fu__initial_carry_in[5] ),
    .initial_carry_out( fu__initial_carry_out[5] ),
    .recv_in_count( fu__recv_in_count[5] ),
    .reset( fu__reset[5] ),
    .from_mem_rdata__en( fu__from_mem_rdata__en[5] ),
    .from_mem_rdata__msg( fu__from_mem_rdata__msg[5] ),
    .from_mem_rdata__rdy( fu__from_mem_rdata__rdy[5] ),
    .recv_const__en( fu__recv_const__en[5] ),
    .recv_const__msg( fu__recv_const__msg[5] ),
    .recv_const__rdy( fu__recv_const__rdy[5] ),
    .recv_in__en( fu__recv_in__en[5] ),
    .recv_in__msg( fu__recv_in__msg[5] ),
    .recv_in__rdy( fu__recv_in__rdy[5] ),
    .recv_opt__en( fu__recv_opt__en[5] ),
    .recv_opt__msg( fu__recv_opt__msg[5] ),
    .recv_opt__rdy( fu__recv_opt__rdy[5] ),
    .recv_predicate__en( fu__recv_predicate__en[5] ),
    .recv_predicate__msg( fu__recv_predicate__msg[5] ),
    .recv_predicate__rdy( fu__recv_predicate__rdy[5] ),
    .send_out__en( fu__send_out__en[5] ),
    .send_out__msg( fu__send_out__msg[5] ),
    .send_out__rdy( fu__send_out__rdy[5] ),
    .to_mem_raddr__en( fu__to_mem_raddr__en[5] ),
    .to_mem_raddr__msg( fu__to_mem_raddr__msg[5] ),
    .to_mem_raddr__rdy( fu__to_mem_raddr__rdy[5] ),
    .to_mem_waddr__en( fu__to_mem_waddr__en[5] ),
    .to_mem_waddr__msg( fu__to_mem_waddr__msg[5] ),
    .to_mem_waddr__rdy( fu__to_mem_waddr__rdy[5] ),
    .to_mem_wdata__en( fu__to_mem_wdata__en[5] ),
    .to_mem_wdata__msg( fu__to_mem_wdata__msg[5] ),
    .to_mem_wdata__rdy( fu__to_mem_wdata__rdy[5] )
  );

  //-------------------------------------------------------------
  // End of component fu[0:5]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At ../../VectorCGRA/fu/flexible/FlexibleFuRTL.py:53
  // @s.update
  // def comb_logic():
  // 
  //   for j in range( num_outports ):
  //     s.send_out[j].en = b1( 0 )
  // 
  //   for i in range( s.fu_list_size ):
  // 
  //     # const connection
  //     s.fu[i].recv_const.msg = s.recv_const.msg
  //     s.fu[i].recv_const.en  = s.recv_const.en
  //     s.recv_const.rdy       = s.recv_const.rdy or s.fu[i].recv_const.rdy
  // 
  //     for j in range( num_inports):
  //       s.fu[i].recv_in_count[j] = s.recv_in_count[j]
  // 
  //     # opt connection
  //     s.fu[i].recv_opt.msg = s.recv_opt.msg
  //     s.fu[i].recv_opt.en  = s.recv_opt.en
  //     s.recv_opt.rdy       = s.fu[i].recv_opt.rdy or s.recv_opt.rdy
  // 
  //     # Note that the predication for a combined FU should be identical/shareable,
  //     # which means the computation in different basic block cannot be combined.
  //     s.fu[i].recv_opt.msg.predicate = s.recv_opt.msg.predicate
  //     s.fu[i].recv_predicate.en      = s.recv_predicate.en
  //     s.recv_predicate.rdy           = s.fu[i].recv_predicate.rdy or s.recv_predicate.rdy
  //     s.fu[i].recv_predicate.msg     = s.recv_predicate.msg
  // 
  //     # send_out connection
  //     for j in range( num_outports ):
  //       if s.fu[i].send_out[j].en:
  //         s.send_out[j].msg     = s.fu[i].send_out[j].msg
  //         s.send_out[j].en      = s.fu[i].send_out[j].en
  //       s.fu[i].send_out[j].rdy = s.send_out[j].rdy
  // 
  // 
  //   for j in range( num_inports ):
  //     s.recv_in[j].rdy = b1( 0 )
  // 
  //   for i in range( s.fu_list_size ):
  //     # recv_in connection
  //     for j in range( num_inports ):
  //       s.fu[i].recv_in[j].msg = s.recv_in[j].msg
  //       s.fu[i].recv_in[j].en  = s.recv_in[j].en
  //       s.recv_in[j].rdy       = s.fu[i].recv_in[j].rdy or s.recv_in[j].rdy
  
  always_comb begin : comb_logic
    for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 )
      send_out__en[j] = 1'd0;
    for ( int i = 0; i < fu_list_size; i += 1 ) begin
      fu__recv_const__msg[i] = recv_const__msg;
      fu__recv_const__en[i] = recv_const__en;
      recv_const__rdy = recv_const__rdy || fu__recv_const__rdy[i];
      for ( int j = 0; j < __const__num_inports_at_comb_logic; j += 1 )
        fu__recv_in_count[i][j] = recv_in_count[j];
      fu__recv_opt__msg[i] = recv_opt__msg;
      fu__recv_opt__en[i] = recv_opt__en;
      recv_opt__rdy = fu__recv_opt__rdy[i] || recv_opt__rdy;
      fu__recv_opt__msg[i].predicate = recv_opt__msg.predicate;
      fu__recv_predicate__en[i] = recv_predicate__en;
      recv_predicate__rdy = fu__recv_predicate__rdy[i] || recv_predicate__rdy;
      fu__recv_predicate__msg[i] = recv_predicate__msg;
      for ( int j = 0; j < __const__num_outports_at_comb_logic; j += 1 ) begin
        if ( fu__send_out__en[i][j] ) begin
          send_out__msg[j] = fu__send_out__msg[i][j];
          send_out__en[j] = fu__send_out__en[i][j];
        end
        fu__send_out__rdy[i][j] = send_out__rdy[j];
      end
    end
    for ( int j = 0; j < __const__num_inports_at_comb_logic; j += 1 )
      recv_in__rdy[j] = 1'd0;
    for ( int i = 0; i < fu_list_size; i += 1 )
      for ( int j = 0; j < __const__num_inports_at_comb_logic; j += 1 ) begin
        fu__recv_in__msg[i][j] = recv_in__msg[j];
        fu__recv_in__en[i][j] = recv_in__en[j];
        recv_in__rdy[j] = fu__recv_in__rdy[i][j] || recv_in__rdy[j];
      end
  end

  assign fu__clk[0] = clk;
  assign fu__reset[0] = reset;
  assign fu__clk[1] = clk;
  assign fu__reset[1] = reset;
  assign fu__clk[2] = clk;
  assign fu__reset[2] = reset;
  assign fu__clk[3] = clk;
  assign fu__reset[3] = reset;
  assign fu__clk[4] = clk;
  assign fu__reset[4] = reset;
  assign fu__clk[5] = clk;
  assign fu__reset[5] = reset;
  assign to_mem_raddr__en[0] = fu__to_mem_raddr__en[0];
  assign to_mem_raddr__msg[0] = fu__to_mem_raddr__msg[0];
  assign fu__to_mem_raddr__rdy[0] = to_mem_raddr__rdy[0];
  assign fu__from_mem_rdata__en[0] = from_mem_rdata__en[0];
  assign fu__from_mem_rdata__msg[0] = from_mem_rdata__msg[0];
  assign from_mem_rdata__rdy[0] = fu__from_mem_rdata__rdy[0];
  assign to_mem_waddr__en[0] = fu__to_mem_waddr__en[0];
  assign to_mem_waddr__msg[0] = fu__to_mem_waddr__msg[0];
  assign fu__to_mem_waddr__rdy[0] = to_mem_waddr__rdy[0];
  assign to_mem_wdata__en[0] = fu__to_mem_wdata__en[0];
  assign to_mem_wdata__msg[0] = fu__to_mem_wdata__msg[0];
  assign fu__to_mem_wdata__rdy[0] = to_mem_wdata__rdy[0];
  assign to_mem_raddr__en[1] = fu__to_mem_raddr__en[1];
  assign to_mem_raddr__msg[1] = fu__to_mem_raddr__msg[1];
  assign fu__to_mem_raddr__rdy[1] = to_mem_raddr__rdy[1];
  assign fu__from_mem_rdata__en[1] = from_mem_rdata__en[1];
  assign fu__from_mem_rdata__msg[1] = from_mem_rdata__msg[1];
  assign from_mem_rdata__rdy[1] = fu__from_mem_rdata__rdy[1];
  assign to_mem_waddr__en[1] = fu__to_mem_waddr__en[1];
  assign to_mem_waddr__msg[1] = fu__to_mem_waddr__msg[1];
  assign fu__to_mem_waddr__rdy[1] = to_mem_waddr__rdy[1];
  assign to_mem_wdata__en[1] = fu__to_mem_wdata__en[1];
  assign to_mem_wdata__msg[1] = fu__to_mem_wdata__msg[1];
  assign fu__to_mem_wdata__rdy[1] = to_mem_wdata__rdy[1];
  assign to_mem_raddr__en[2] = fu__to_mem_raddr__en[2];
  assign to_mem_raddr__msg[2] = fu__to_mem_raddr__msg[2];
  assign fu__to_mem_raddr__rdy[2] = to_mem_raddr__rdy[2];
  assign fu__from_mem_rdata__en[2] = from_mem_rdata__en[2];
  assign fu__from_mem_rdata__msg[2] = from_mem_rdata__msg[2];
  assign from_mem_rdata__rdy[2] = fu__from_mem_rdata__rdy[2];
  assign to_mem_waddr__en[2] = fu__to_mem_waddr__en[2];
  assign to_mem_waddr__msg[2] = fu__to_mem_waddr__msg[2];
  assign fu__to_mem_waddr__rdy[2] = to_mem_waddr__rdy[2];
  assign to_mem_wdata__en[2] = fu__to_mem_wdata__en[2];
  assign to_mem_wdata__msg[2] = fu__to_mem_wdata__msg[2];
  assign fu__to_mem_wdata__rdy[2] = to_mem_wdata__rdy[2];
  assign to_mem_raddr__en[3] = fu__to_mem_raddr__en[3];
  assign to_mem_raddr__msg[3] = fu__to_mem_raddr__msg[3];
  assign fu__to_mem_raddr__rdy[3] = to_mem_raddr__rdy[3];
  assign fu__from_mem_rdata__en[3] = from_mem_rdata__en[3];
  assign fu__from_mem_rdata__msg[3] = from_mem_rdata__msg[3];
  assign from_mem_rdata__rdy[3] = fu__from_mem_rdata__rdy[3];
  assign to_mem_waddr__en[3] = fu__to_mem_waddr__en[3];
  assign to_mem_waddr__msg[3] = fu__to_mem_waddr__msg[3];
  assign fu__to_mem_waddr__rdy[3] = to_mem_waddr__rdy[3];
  assign to_mem_wdata__en[3] = fu__to_mem_wdata__en[3];
  assign to_mem_wdata__msg[3] = fu__to_mem_wdata__msg[3];
  assign fu__to_mem_wdata__rdy[3] = to_mem_wdata__rdy[3];
  assign to_mem_raddr__en[4] = fu__to_mem_raddr__en[4];
  assign to_mem_raddr__msg[4] = fu__to_mem_raddr__msg[4];
  assign fu__to_mem_raddr__rdy[4] = to_mem_raddr__rdy[4];
  assign fu__from_mem_rdata__en[4] = from_mem_rdata__en[4];
  assign fu__from_mem_rdata__msg[4] = from_mem_rdata__msg[4];
  assign from_mem_rdata__rdy[4] = fu__from_mem_rdata__rdy[4];
  assign to_mem_waddr__en[4] = fu__to_mem_waddr__en[4];
  assign to_mem_waddr__msg[4] = fu__to_mem_waddr__msg[4];
  assign fu__to_mem_waddr__rdy[4] = to_mem_waddr__rdy[4];
  assign to_mem_wdata__en[4] = fu__to_mem_wdata__en[4];
  assign to_mem_wdata__msg[4] = fu__to_mem_wdata__msg[4];
  assign fu__to_mem_wdata__rdy[4] = to_mem_wdata__rdy[4];
  assign to_mem_raddr__en[5] = fu__to_mem_raddr__en[5];
  assign to_mem_raddr__msg[5] = fu__to_mem_raddr__msg[5];
  assign fu__to_mem_raddr__rdy[5] = to_mem_raddr__rdy[5];
  assign fu__from_mem_rdata__en[5] = from_mem_rdata__en[5];
  assign fu__from_mem_rdata__msg[5] = from_mem_rdata__msg[5];
  assign from_mem_rdata__rdy[5] = fu__from_mem_rdata__rdy[5];
  assign to_mem_waddr__en[5] = fu__to_mem_waddr__en[5];
  assign to_mem_waddr__msg[5] = fu__to_mem_waddr__msg[5];
  assign fu__to_mem_waddr__rdy[5] = to_mem_waddr__rdy[5];
  assign to_mem_wdata__en[5] = fu__to_mem_wdata__en[5];
  assign to_mem_wdata__msg[5] = fu__to_mem_wdata__msg[5];
  assign fu__to_mem_wdata__rdy[5] = to_mem_wdata__rdy[5];

endmodule


// PyMTL Component RegisterFile Definition
// Full name: RegisterFile__Type_CGRAData_1_1__nregs_2__rd_ports_1__wr_ports_1__const_zero_False
// At /home/rms/mambaforge/envs/pycgra/lib/python3.7/site-packages/pymtl3/stdlib/rtl/RegisterFile.py

module RegisterFile__b2651f5e70154f41
(
  input logic [0:0] clk,
  input logic [0:0] raddr [0:0],
  output CGRAData_1_1 rdata [0:0],
  input logic [0:0] reset,
  input logic [0:0] waddr [0:0],
  input CGRAData_1_1 wdata [0:0],
  input logic [0:0] wen [0:0]
);
  localparam logic [31:0] __const__rd_ports_at_up_rf_read = 32'd1;
  localparam logic [31:0] __const__wr_ports_at_up_rf_write = 32'd1;
  CGRAData_1_1 regs [0:1] ;

  // PyMTL Update Block Source
  // At /home/rms/mambaforge/envs/pycgra/lib/python3.7/site-packages/pymtl3/stdlib/rtl/RegisterFile.py:20
  // @s.update
  // def up_rf_read():
  //   for i in range( rd_ports ):
  //     s.rdata[i] = s.regs[ s.raddr[i] ]
  
  always_comb begin : up_rf_read
    for ( int i = 0; i < __const__rd_ports_at_up_rf_read; i += 1 )
      rdata[i] = regs[raddr[i]];
  end

  // PyMTL Update Block Source
  // At /home/rms/mambaforge/envs/pycgra/lib/python3.7/site-packages/pymtl3/stdlib/rtl/RegisterFile.py:32
  // @s.update_ff
  // def up_rf_write():
  //   for i in range( wr_ports ):
  //     if s.wen[i]:
  //       s.regs[ s.waddr[i] ] <<= s.wdata[i]
  
  always_ff @(posedge clk) begin : up_rf_write
    for ( int i = 0; i < __const__wr_ports_at_up_rf_write; i += 1 )
      if ( wen[i] ) begin
        regs[waddr[i]] <= wdata[i];
      end
  end

endmodule


// PyMTL Component NormalQueueDpathRTL Definition
// At /home/rms/mambaforge/envs/pycgra/lib/python3.7/site-packages/pymtl3/stdlib/rtl/queues.py

module NormalQueueDpathRTL__EntryType_CGRAData_1_1__num_entries_2
(
  input logic [0:0] clk,
  output CGRAData_1_1 deq_ret,
  input CGRAData_1_1 enq_msg,
  input logic [0:0] raddr,
  input logic [0:0] reset,
  input logic [0:0] waddr,
  input logic [0:0] wen
);
  //-------------------------------------------------------------
  // Component queue
  //-------------------------------------------------------------

  logic [0:0] queue__clk ;
  logic [0:0] queue__raddr [0:0] ;
  CGRAData_1_1 queue__rdata [0:0] ;
  logic [0:0] queue__reset ;
  logic [0:0] queue__waddr [0:0] ;
  CGRAData_1_1 queue__wdata [0:0] ;
  logic [0:0] queue__wen [0:0] ;

  RegisterFile__b2651f5e70154f41 queue
  (
    .clk( queue__clk ),
    .raddr( queue__raddr ),
    .rdata( queue__rdata ),
    .reset( queue__reset ),
    .waddr( queue__waddr ),
    .wdata( queue__wdata ),
    .wen( queue__wen )
  );

  //-------------------------------------------------------------
  // End of component queue
  //-------------------------------------------------------------

  assign queue__clk = clk;
  assign queue__reset = reset;
  assign queue__raddr[0] = raddr;
  assign deq_ret = queue__rdata[0];
  assign queue__wen[0] = wen;
  assign queue__waddr[0] = waddr;
  assign queue__wdata[0] = enq_msg;

endmodule


// PyMTL Component NormalQueueRTL Definition
// At /home/rms/mambaforge/envs/pycgra/lib/python3.7/site-packages/pymtl3/stdlib/rtl/queues.py

module NormalQueueRTL__EntryType_CGRAData_1_1__num_entries_2
(
  input logic [0:0] clk,
  output logic [1:0] count,
  input logic [0:0] reset,
  input logic [0:0] deq__en,
  output logic [0:0] deq__rdy,
  output CGRAData_1_1 deq__ret,
  input logic [0:0] enq__en,
  input CGRAData_1_1 enq__msg,
  output logic [0:0] enq__rdy
);
  //-------------------------------------------------------------
  // Component ctrl
  //-------------------------------------------------------------

  logic [0:0] ctrl__clk ;
  logic [1:0] ctrl__count ;
  logic [0:0] ctrl__deq_en ;
  logic [0:0] ctrl__deq_rdy ;
  logic [0:0] ctrl__enq_en ;
  logic [0:0] ctrl__enq_rdy ;
  logic [0:0] ctrl__raddr ;
  logic [0:0] ctrl__reset ;
  logic [0:0] ctrl__waddr ;
  logic [0:0] ctrl__wen ;

  NormalQueueCtrlRTL__num_entries_2 ctrl
  (
    .clk( ctrl__clk ),
    .count( ctrl__count ),
    .deq_en( ctrl__deq_en ),
    .deq_rdy( ctrl__deq_rdy ),
    .enq_en( ctrl__enq_en ),
    .enq_rdy( ctrl__enq_rdy ),
    .raddr( ctrl__raddr ),
    .reset( ctrl__reset ),
    .waddr( ctrl__waddr ),
    .wen( ctrl__wen )
  );

  //-------------------------------------------------------------
  // End of component ctrl
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component dpath
  //-------------------------------------------------------------

  logic [0:0] dpath__clk ;
  CGRAData_1_1 dpath__deq_ret ;
  CGRAData_1_1 dpath__enq_msg ;
  logic [0:0] dpath__raddr ;
  logic [0:0] dpath__reset ;
  logic [0:0] dpath__waddr ;
  logic [0:0] dpath__wen ;

  NormalQueueDpathRTL__EntryType_CGRAData_1_1__num_entries_2 dpath
  (
    .clk( dpath__clk ),
    .deq_ret( dpath__deq_ret ),
    .enq_msg( dpath__enq_msg ),
    .raddr( dpath__raddr ),
    .reset( dpath__reset ),
    .waddr( dpath__waddr ),
    .wen( dpath__wen )
  );

  //-------------------------------------------------------------
  // End of component dpath
  //-------------------------------------------------------------

  assign ctrl__clk = clk;
  assign ctrl__reset = reset;
  assign dpath__clk = clk;
  assign dpath__reset = reset;
  assign dpath__wen = ctrl__wen;
  assign dpath__waddr = ctrl__waddr;
  assign dpath__raddr = ctrl__raddr;
  assign ctrl__enq_en = enq__en;
  assign enq__rdy = ctrl__enq_rdy;
  assign ctrl__deq_en = deq__en;
  assign deq__rdy = ctrl__deq_rdy;
  assign count = ctrl__count;
  assign dpath__enq_msg = enq__msg;
  assign deq__ret = dpath__deq_ret;

endmodule


// PyMTL Component RegisterRTL Definition
// At ../../VectorCGRA/rf/RegisterRTL.py

module RegisterRTL__DataType_CGRAData_1_1__latency_1
(
  input logic [0:0] clk,
  input logic [0:0] reset,
  input logic [0:0] recv__en,
  input CGRAData_1_1 recv__msg,
  output logic [0:0] recv__rdy,
  output logic [0:0] send__en,
  output CGRAData_1_1 send__msg,
  input logic [0:0] send__rdy
);
  localparam logic [31:0] latency = 32'd1;
  //-------------------------------------------------------------
  // Component queues[0:0]
  //-------------------------------------------------------------

  logic [0:0] queues__clk [0:0] ;
  logic [1:0] queues__count [0:0] ;
  logic [0:0] queues__reset [0:0] ;
  logic [0:0] queues__deq__en [0:0] ;
  logic [0:0] queues__deq__rdy [0:0] ;
  CGRAData_1_1 queues__deq__ret [0:0] ;
  logic [0:0] queues__enq__en [0:0] ;
  CGRAData_1_1 queues__enq__msg [0:0] ;
  logic [0:0] queues__enq__rdy [0:0] ;

  NormalQueueRTL__EntryType_CGRAData_1_1__num_entries_2 queues__0
  (
    .clk( queues__clk[0] ),
    .count( queues__count[0] ),
    .reset( queues__reset[0] ),
    .deq__en( queues__deq__en[0] ),
    .deq__rdy( queues__deq__rdy[0] ),
    .deq__ret( queues__deq__ret[0] ),
    .enq__en( queues__enq__en[0] ),
    .enq__msg( queues__enq__msg[0] ),
    .enq__rdy( queues__enq__rdy[0] )
  );

  //-------------------------------------------------------------
  // End of component queues[0:0]
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At ../../VectorCGRA/rf/RegisterRTL.py:30
  //   @s.update
  //   def process():
  //     s.recv.rdy = s.queues[0].enq.rdy
  //     s.queues[0].enq.msg = s.recv.msg
  //     s.queues[0].enq.en  = s.recv.en and s.queues[0].enq.rdy
  //     for i in range(s.latency - 1):
  //       s.queues[i+1].enq.msg = s.queues[i].deq.ret
  //       s.queues[i+1].enq.en  = s.queues[i].deq.rdy and s.queues[i+1].enq.rdy
  //       s.queues[i].deq.en    = s.queues[i+1].enq.en
  // 
  //     s.send.msg  = s.queues[s.latency-1].deq.ret
  //     s.send.en   = s.send.rdy and s.queues[s.latency-1].deq.rdy
  //     s.queues[s.latency-1].deq.en   = s.send.en
  
  always_comb begin : process
    recv__rdy = queues__enq__rdy[0];
    queues__enq__msg[0] = recv__msg;
    queues__enq__en[0] = recv__en && queues__enq__rdy[0];
    for ( int i = 0; i < latency - 1; i += 1 ) begin
      queues__enq__msg[i + 1] = queues__deq__ret[i];
      queues__enq__en[i + 1] = queues__deq__rdy[i] && queues__enq__rdy[i + 1];
      queues__deq__en[i] = queues__enq__en[i + 1];
    end
    send__msg = queues__deq__ret[latency - 1];
    send__en = send__rdy && queues__deq__rdy[latency - 1];
    queues__deq__en[latency - 1] = send__en;
  end

  assign queues__clk[0] = clk;
  assign queues__reset[0] = reset;

endmodule


// PyMTL Component TileRTL Definition
// Full name: TileRTL__DataType_CGRAData_32_1_1__PredicateType_CGRAData_1_1__CtrlType_CGRAConfig_6_4_8_8__ctrl_mem_size_8__data_mem_size_8__num_ctrl_4__num_fu_inports_4__num_fu_outports_2__num_connect_inports_8__num_connect_outports_8__Fu_FlexibleFuRTL__FuList_[<class 'VectorCGRA.fu.single.PhiRTL.PhiRTL'>, <class 'VectorCGRA.fu.single.AdderRTL.AdderRTL'>, <class 'VectorCGRA.fu.single.CompRTL.CompRTL'>, <class 'VectorCGRA.fu.single.MulRTL.MulRTL'>, <class 'VectorCGRA.fu.single.BranchRTL.BranchRTL'>, <class 'VectorCGRA.fu.single.MemUnitRTL.MemUnitRTL'>]__const_list_[CGRAData_32_1_1(Bits32(0x00000000),Bits1(0x0),Bits1(0x0))]
// At ../../VectorCGRA/tile/TileRTL.py

module TileRTL__40947ac956b390e0
(
  input logic [0:0] clk,
  input logic [0:0] reset,
  input logic [0:0] from_mem_rdata__en,
  input CGRAData_32_1_1 from_mem_rdata__msg,
  output logic [0:0] from_mem_rdata__rdy,
  input logic [0:0] recv_data__en [0:7],
  input CGRAData_32_1_1 recv_data__msg [0:7],
  output logic [0:0] recv_data__rdy [0:7],
  input logic [0:0] recv_waddr__en,
  input logic [2:0] recv_waddr__msg,
  output logic [0:0] recv_waddr__rdy,
  input logic [0:0] recv_wopt__en,
  input CGRAConfig_6_4_8_8 recv_wopt__msg,
  output logic [0:0] recv_wopt__rdy,
  output logic [0:0] send_data__en [0:7],
  output CGRAData_32_1_1 send_data__msg [0:7],
  input logic [0:0] send_data__rdy [0:7],
  output logic [0:0] to_mem_raddr__en,
  output logic [2:0] to_mem_raddr__msg,
  input logic [0:0] to_mem_raddr__rdy,
  output logic [0:0] to_mem_waddr__en,
  output logic [2:0] to_mem_waddr__msg,
  input logic [0:0] to_mem_waddr__rdy,
  output logic [0:0] to_mem_wdata__en,
  output CGRAData_32_1_1 to_mem_wdata__msg,
  input logic [0:0] to_mem_wdata__rdy
);
  //-------------------------------------------------------------
  // Component channel[0:11]
  //-------------------------------------------------------------

  logic [0:0] channel__clk [0:11] ;
  logic [1:0] channel__count [0:11] ;
  logic [0:0] channel__reset [0:11] ;
  logic [0:0] channel__recv__en [0:11] ;
  CGRAData_32_1_1 channel__recv__msg [0:11] ;
  logic [0:0] channel__recv__rdy [0:11] ;
  logic [0:0] channel__send__en [0:11] ;
  CGRAData_32_1_1 channel__send__msg [0:11] ;
  logic [0:0] channel__send__rdy [0:11] ;

  ChannelRTL__DataType_CGRAData_32_1_1__latency_1 channel__0
  (
    .clk( channel__clk[0] ),
    .count( channel__count[0] ),
    .reset( channel__reset[0] ),
    .recv__en( channel__recv__en[0] ),
    .recv__msg( channel__recv__msg[0] ),
    .recv__rdy( channel__recv__rdy[0] ),
    .send__en( channel__send__en[0] ),
    .send__msg( channel__send__msg[0] ),
    .send__rdy( channel__send__rdy[0] )
  );

  ChannelRTL__DataType_CGRAData_32_1_1__latency_1 channel__1
  (
    .clk( channel__clk[1] ),
    .count( channel__count[1] ),
    .reset( channel__reset[1] ),
    .recv__en( channel__recv__en[1] ),
    .recv__msg( channel__recv__msg[1] ),
    .recv__rdy( channel__recv__rdy[1] ),
    .send__en( channel__send__en[1] ),
    .send__msg( channel__send__msg[1] ),
    .send__rdy( channel__send__rdy[1] )
  );

  ChannelRTL__DataType_CGRAData_32_1_1__latency_1 channel__2
  (
    .clk( channel__clk[2] ),
    .count( channel__count[2] ),
    .reset( channel__reset[2] ),
    .recv__en( channel__recv__en[2] ),
    .recv__msg( channel__recv__msg[2] ),
    .recv__rdy( channel__recv__rdy[2] ),
    .send__en( channel__send__en[2] ),
    .send__msg( channel__send__msg[2] ),
    .send__rdy( channel__send__rdy[2] )
  );

  ChannelRTL__DataType_CGRAData_32_1_1__latency_1 channel__3
  (
    .clk( channel__clk[3] ),
    .count( channel__count[3] ),
    .reset( channel__reset[3] ),
    .recv__en( channel__recv__en[3] ),
    .recv__msg( channel__recv__msg[3] ),
    .recv__rdy( channel__recv__rdy[3] ),
    .send__en( channel__send__en[3] ),
    .send__msg( channel__send__msg[3] ),
    .send__rdy( channel__send__rdy[3] )
  );

  ChannelRTL__DataType_CGRAData_32_1_1__latency_1 channel__4
  (
    .clk( channel__clk[4] ),
    .count( channel__count[4] ),
    .reset( channel__reset[4] ),
    .recv__en( channel__recv__en[4] ),
    .recv__msg( channel__recv__msg[4] ),
    .recv__rdy( channel__recv__rdy[4] ),
    .send__en( channel__send__en[4] ),
    .send__msg( channel__send__msg[4] ),
    .send__rdy( channel__send__rdy[4] )
  );

  ChannelRTL__DataType_CGRAData_32_1_1__latency_1 channel__5
  (
    .clk( channel__clk[5] ),
    .count( channel__count[5] ),
    .reset( channel__reset[5] ),
    .recv__en( channel__recv__en[5] ),
    .recv__msg( channel__recv__msg[5] ),
    .recv__rdy( channel__recv__rdy[5] ),
    .send__en( channel__send__en[5] ),
    .send__msg( channel__send__msg[5] ),
    .send__rdy( channel__send__rdy[5] )
  );

  ChannelRTL__DataType_CGRAData_32_1_1__latency_1 channel__6
  (
    .clk( channel__clk[6] ),
    .count( channel__count[6] ),
    .reset( channel__reset[6] ),
    .recv__en( channel__recv__en[6] ),
    .recv__msg( channel__recv__msg[6] ),
    .recv__rdy( channel__recv__rdy[6] ),
    .send__en( channel__send__en[6] ),
    .send__msg( channel__send__msg[6] ),
    .send__rdy( channel__send__rdy[6] )
  );

  ChannelRTL__DataType_CGRAData_32_1_1__latency_1 channel__7
  (
    .clk( channel__clk[7] ),
    .count( channel__count[7] ),
    .reset( channel__reset[7] ),
    .recv__en( channel__recv__en[7] ),
    .recv__msg( channel__recv__msg[7] ),
    .recv__rdy( channel__recv__rdy[7] ),
    .send__en( channel__send__en[7] ),
    .send__msg( channel__send__msg[7] ),
    .send__rdy( channel__send__rdy[7] )
  );

  ChannelRTL__DataType_CGRAData_32_1_1__latency_1 channel__8
  (
    .clk( channel__clk[8] ),
    .count( channel__count[8] ),
    .reset( channel__reset[8] ),
    .recv__en( channel__recv__en[8] ),
    .recv__msg( channel__recv__msg[8] ),
    .recv__rdy( channel__recv__rdy[8] ),
    .send__en( channel__send__en[8] ),
    .send__msg( channel__send__msg[8] ),
    .send__rdy( channel__send__rdy[8] )
  );

  ChannelRTL__DataType_CGRAData_32_1_1__latency_1 channel__9
  (
    .clk( channel__clk[9] ),
    .count( channel__count[9] ),
    .reset( channel__reset[9] ),
    .recv__en( channel__recv__en[9] ),
    .recv__msg( channel__recv__msg[9] ),
    .recv__rdy( channel__recv__rdy[9] ),
    .send__en( channel__send__en[9] ),
    .send__msg( channel__send__msg[9] ),
    .send__rdy( channel__send__rdy[9] )
  );

  ChannelRTL__DataType_CGRAData_32_1_1__latency_1 channel__10
  (
    .clk( channel__clk[10] ),
    .count( channel__count[10] ),
    .reset( channel__reset[10] ),
    .recv__en( channel__recv__en[10] ),
    .recv__msg( channel__recv__msg[10] ),
    .recv__rdy( channel__recv__rdy[10] ),
    .send__en( channel__send__en[10] ),
    .send__msg( channel__send__msg[10] ),
    .send__rdy( channel__send__rdy[10] )
  );

  ChannelRTL__DataType_CGRAData_32_1_1__latency_1 channel__11
  (
    .clk( channel__clk[11] ),
    .count( channel__count[11] ),
    .reset( channel__reset[11] ),
    .recv__en( channel__recv__en[11] ),
    .recv__msg( channel__recv__msg[11] ),
    .recv__rdy( channel__recv__rdy[11] ),
    .send__en( channel__send__en[11] ),
    .send__msg( channel__send__msg[11] ),
    .send__rdy( channel__send__rdy[11] )
  );

  //-------------------------------------------------------------
  // End of component channel[0:11]
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component const_queue
  //-------------------------------------------------------------

  logic [0:0] const_queue__clk ;
  logic [0:0] const_queue__reset ;
  logic [0:0] const_queue__send_const__en ;
  CGRAData_32_1_1 const_queue__send_const__msg ;
  logic [0:0] const_queue__send_const__rdy ;

  ConstQueueRTL__2f4560623c67a554 const_queue
  (
    .clk( const_queue__clk ),
    .reset( const_queue__reset ),
    .send_const__en( const_queue__send_const__en ),
    .send_const__msg( const_queue__send_const__msg ),
    .send_const__rdy( const_queue__send_const__rdy )
  );

  //-------------------------------------------------------------
  // End of component const_queue
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component crossbar
  //-------------------------------------------------------------

  logic [0:0] crossbar__clk ;
  logic [0:0] crossbar__reset ;
  logic [0:0] crossbar__recv_data__en [0:9] ;
  CGRAData_32_1_1 crossbar__recv_data__msg [0:9] ;
  logic [0:0] crossbar__recv_data__rdy [0:9] ;
  logic [0:0] crossbar__recv_opt__en ;
  CGRAConfig_6_4_8_8 crossbar__recv_opt__msg ;
  logic [0:0] crossbar__recv_opt__rdy ;
  logic [0:0] crossbar__send_data__en [0:11] ;
  CGRAData_32_1_1 crossbar__send_data__msg [0:11] ;
  logic [0:0] crossbar__send_data__rdy [0:11] ;
  logic [0:0] crossbar__send_predicate__en ;
  CGRAData_1_1 crossbar__send_predicate__msg ;
  logic [0:0] crossbar__send_predicate__rdy ;

  CrossbarRTL__874305e17dbe6b02 crossbar
  (
    .clk( crossbar__clk ),
    .reset( crossbar__reset ),
    .recv_data__en( crossbar__recv_data__en ),
    .recv_data__msg( crossbar__recv_data__msg ),
    .recv_data__rdy( crossbar__recv_data__rdy ),
    .recv_opt__en( crossbar__recv_opt__en ),
    .recv_opt__msg( crossbar__recv_opt__msg ),
    .recv_opt__rdy( crossbar__recv_opt__rdy ),
    .send_data__en( crossbar__send_data__en ),
    .send_data__msg( crossbar__send_data__msg ),
    .send_data__rdy( crossbar__send_data__rdy ),
    .send_predicate__en( crossbar__send_predicate__en ),
    .send_predicate__msg( crossbar__send_predicate__msg ),
    .send_predicate__rdy( crossbar__send_predicate__rdy )
  );

  //-------------------------------------------------------------
  // End of component crossbar
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component ctrl_mem
  //-------------------------------------------------------------

  logic [0:0] ctrl_mem__clk ;
  logic [0:0] ctrl_mem__reset ;
  logic [0:0] ctrl_mem__recv_ctrl__en ;
  CGRAConfig_6_4_8_8 ctrl_mem__recv_ctrl__msg ;
  logic [0:0] ctrl_mem__recv_ctrl__rdy ;
  logic [0:0] ctrl_mem__recv_waddr__en ;
  logic [2:0] ctrl_mem__recv_waddr__msg ;
  logic [0:0] ctrl_mem__recv_waddr__rdy ;
  logic [0:0] ctrl_mem__send_ctrl__en ;
  CGRAConfig_6_4_8_8 ctrl_mem__send_ctrl__msg ;
  logic [0:0] ctrl_mem__send_ctrl__rdy ;

  CtrlMemRTL__ebe00becbc7c6d54 ctrl_mem
  (
    .clk( ctrl_mem__clk ),
    .reset( ctrl_mem__reset ),
    .recv_ctrl__en( ctrl_mem__recv_ctrl__en ),
    .recv_ctrl__msg( ctrl_mem__recv_ctrl__msg ),
    .recv_ctrl__rdy( ctrl_mem__recv_ctrl__rdy ),
    .recv_waddr__en( ctrl_mem__recv_waddr__en ),
    .recv_waddr__msg( ctrl_mem__recv_waddr__msg ),
    .recv_waddr__rdy( ctrl_mem__recv_waddr__rdy ),
    .send_ctrl__en( ctrl_mem__send_ctrl__en ),
    .send_ctrl__msg( ctrl_mem__send_ctrl__msg ),
    .send_ctrl__rdy( ctrl_mem__send_ctrl__rdy )
  );

  //-------------------------------------------------------------
  // End of component ctrl_mem
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component element
  //-------------------------------------------------------------

  logic [0:0] element__clk ;
  logic [1:0] element__recv_in_count [0:3] ;
  logic [0:0] element__reset ;
  logic [0:0] element__from_mem_rdata__en [0:5] ;
  CGRAData_32_1_1 element__from_mem_rdata__msg [0:5] ;
  logic [0:0] element__from_mem_rdata__rdy [0:5] ;
  logic [0:0] element__recv_const__en ;
  CGRAData_32_1_1 element__recv_const__msg ;
  logic [0:0] element__recv_const__rdy ;
  logic [0:0] element__recv_in__en [0:3] ;
  CGRAData_32_1_1 element__recv_in__msg [0:3] ;
  logic [0:0] element__recv_in__rdy [0:3] ;
  logic [0:0] element__recv_opt__en ;
  CGRAConfig_6_4_8_8 element__recv_opt__msg ;
  logic [0:0] element__recv_opt__rdy ;
  logic [0:0] element__recv_predicate__en ;
  CGRAData_1_1 element__recv_predicate__msg ;
  logic [0:0] element__recv_predicate__rdy ;
  logic [0:0] element__send_out__en [0:1] ;
  CGRAData_32_1_1 element__send_out__msg [0:1] ;
  logic [0:0] element__send_out__rdy [0:1] ;
  logic [0:0] element__to_mem_raddr__en [0:5] ;
  logic [2:0] element__to_mem_raddr__msg [0:5] ;
  logic [0:0] element__to_mem_raddr__rdy [0:5] ;
  logic [0:0] element__to_mem_waddr__en [0:5] ;
  logic [2:0] element__to_mem_waddr__msg [0:5] ;
  logic [0:0] element__to_mem_waddr__rdy [0:5] ;
  logic [0:0] element__to_mem_wdata__en [0:5] ;
  CGRAData_32_1_1 element__to_mem_wdata__msg [0:5] ;
  logic [0:0] element__to_mem_wdata__rdy [0:5] ;

  FlexibleFuRTL__7ccad8d3ed73c188 element
  (
    .clk( element__clk ),
    .recv_in_count( element__recv_in_count ),
    .reset( element__reset ),
    .from_mem_rdata__en( element__from_mem_rdata__en ),
    .from_mem_rdata__msg( element__from_mem_rdata__msg ),
    .from_mem_rdata__rdy( element__from_mem_rdata__rdy ),
    .recv_const__en( element__recv_const__en ),
    .recv_const__msg( element__recv_const__msg ),
    .recv_const__rdy( element__recv_const__rdy ),
    .recv_in__en( element__recv_in__en ),
    .recv_in__msg( element__recv_in__msg ),
    .recv_in__rdy( element__recv_in__rdy ),
    .recv_opt__en( element__recv_opt__en ),
    .recv_opt__msg( element__recv_opt__msg ),
    .recv_opt__rdy( element__recv_opt__rdy ),
    .recv_predicate__en( element__recv_predicate__en ),
    .recv_predicate__msg( element__recv_predicate__msg ),
    .recv_predicate__rdy( element__recv_predicate__rdy ),
    .send_out__en( element__send_out__en ),
    .send_out__msg( element__send_out__msg ),
    .send_out__rdy( element__send_out__rdy ),
    .to_mem_raddr__en( element__to_mem_raddr__en ),
    .to_mem_raddr__msg( element__to_mem_raddr__msg ),
    .to_mem_raddr__rdy( element__to_mem_raddr__rdy ),
    .to_mem_waddr__en( element__to_mem_waddr__en ),
    .to_mem_waddr__msg( element__to_mem_waddr__msg ),
    .to_mem_waddr__rdy( element__to_mem_waddr__rdy ),
    .to_mem_wdata__en( element__to_mem_wdata__en ),
    .to_mem_wdata__msg( element__to_mem_wdata__msg ),
    .to_mem_wdata__rdy( element__to_mem_wdata__rdy )
  );

  //-------------------------------------------------------------
  // End of component element
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component reg_predicate
  //-------------------------------------------------------------

  logic [0:0] reg_predicate__clk ;
  logic [0:0] reg_predicate__reset ;
  logic [0:0] reg_predicate__recv__en ;
  CGRAData_1_1 reg_predicate__recv__msg ;
  logic [0:0] reg_predicate__recv__rdy ;
  logic [0:0] reg_predicate__send__en ;
  CGRAData_1_1 reg_predicate__send__msg ;
  logic [0:0] reg_predicate__send__rdy ;

  RegisterRTL__DataType_CGRAData_1_1__latency_1 reg_predicate
  (
    .clk( reg_predicate__clk ),
    .reset( reg_predicate__reset ),
    .recv__en( reg_predicate__recv__en ),
    .recv__msg( reg_predicate__recv__msg ),
    .recv__rdy( reg_predicate__recv__rdy ),
    .send__en( reg_predicate__send__en ),
    .send__msg( reg_predicate__send__msg ),
    .send__rdy( reg_predicate__send__rdy )
  );

  //-------------------------------------------------------------
  // End of component reg_predicate
  //-------------------------------------------------------------

  // PyMTL Update Block Source
  // At ../../VectorCGRA/tile/TileRTL.py:112
  // @s.update
  // def update_opt():
  //   s.element.recv_opt.msg  = s.ctrl_mem.send_ctrl.msg
  //   s.crossbar.recv_opt.msg = s.ctrl_mem.send_ctrl.msg
  //   s.element.recv_opt.en  = s.ctrl_mem.send_ctrl.en
  //   s.crossbar.recv_opt.en = s.ctrl_mem.send_ctrl.en
  //   s.ctrl_mem.send_ctrl.rdy = s.element.recv_opt.rdy and s.crossbar.recv_opt.rdy
  
  always_comb begin : update_opt
    element__recv_opt__msg = ctrl_mem__send_ctrl__msg;
    crossbar__recv_opt__msg = ctrl_mem__send_ctrl__msg;
    element__recv_opt__en = ctrl_mem__send_ctrl__en;
    crossbar__recv_opt__en = ctrl_mem__send_ctrl__en;
    ctrl_mem__send_ctrl__rdy = element__recv_opt__rdy && crossbar__recv_opt__rdy;
  end

  assign element__clk = clk;
  assign element__reset = reset;
  assign const_queue__clk = clk;
  assign const_queue__reset = reset;
  assign crossbar__clk = clk;
  assign crossbar__reset = reset;
  assign ctrl_mem__clk = clk;
  assign ctrl_mem__reset = reset;
  assign channel__clk[0] = clk;
  assign channel__reset[0] = reset;
  assign channel__clk[1] = clk;
  assign channel__reset[1] = reset;
  assign channel__clk[2] = clk;
  assign channel__reset[2] = reset;
  assign channel__clk[3] = clk;
  assign channel__reset[3] = reset;
  assign channel__clk[4] = clk;
  assign channel__reset[4] = reset;
  assign channel__clk[5] = clk;
  assign channel__reset[5] = reset;
  assign channel__clk[6] = clk;
  assign channel__reset[6] = reset;
  assign channel__clk[7] = clk;
  assign channel__reset[7] = reset;
  assign channel__clk[8] = clk;
  assign channel__reset[8] = reset;
  assign channel__clk[9] = clk;
  assign channel__reset[9] = reset;
  assign channel__clk[10] = clk;
  assign channel__reset[10] = reset;
  assign channel__clk[11] = clk;
  assign channel__reset[11] = reset;
  assign reg_predicate__clk = clk;
  assign reg_predicate__reset = reset;
  assign ctrl_mem__recv_waddr__en = recv_waddr__en;
  assign ctrl_mem__recv_waddr__msg = recv_waddr__msg;
  assign recv_waddr__rdy = ctrl_mem__recv_waddr__rdy;
  assign ctrl_mem__recv_ctrl__en = recv_wopt__en;
  assign ctrl_mem__recv_ctrl__msg = recv_wopt__msg;
  assign recv_wopt__rdy = ctrl_mem__recv_ctrl__rdy;
  assign element__recv_const__en = const_queue__send_const__en;
  assign element__recv_const__msg = const_queue__send_const__msg;
  assign const_queue__send_const__rdy = element__recv_const__rdy;
  assign element__to_mem_raddr__rdy[0] = 1'd0;
  assign element__from_mem_rdata__en[0] = 1'd0;
  assign element__from_mem_rdata__msg[0] = { 32'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[0] = 1'd0;
  assign element__to_mem_wdata__rdy[0] = 1'd0;
  assign element__to_mem_raddr__rdy[1] = 1'd0;
  assign element__from_mem_rdata__en[1] = 1'd0;
  assign element__from_mem_rdata__msg[1] = { 32'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[1] = 1'd0;
  assign element__to_mem_wdata__rdy[1] = 1'd0;
  assign element__to_mem_raddr__rdy[2] = 1'd0;
  assign element__from_mem_rdata__en[2] = 1'd0;
  assign element__from_mem_rdata__msg[2] = { 32'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[2] = 1'd0;
  assign element__to_mem_wdata__rdy[2] = 1'd0;
  assign element__to_mem_raddr__rdy[3] = 1'd0;
  assign element__from_mem_rdata__en[3] = 1'd0;
  assign element__from_mem_rdata__msg[3] = { 32'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[3] = 1'd0;
  assign element__to_mem_wdata__rdy[3] = 1'd0;
  assign element__to_mem_raddr__rdy[4] = 1'd0;
  assign element__from_mem_rdata__en[4] = 1'd0;
  assign element__from_mem_rdata__msg[4] = { 32'd0, 1'd0, 1'd0 };
  assign element__to_mem_waddr__rdy[4] = 1'd0;
  assign element__to_mem_wdata__rdy[4] = 1'd0;
  assign to_mem_raddr__en = element__to_mem_raddr__en[5];
  assign to_mem_raddr__msg = element__to_mem_raddr__msg[5];
  assign element__to_mem_raddr__rdy[5] = to_mem_raddr__rdy;
  assign element__from_mem_rdata__en[5] = from_mem_rdata__en;
  assign element__from_mem_rdata__msg[5] = from_mem_rdata__msg;
  assign from_mem_rdata__rdy = element__from_mem_rdata__rdy[5];
  assign to_mem_waddr__en = element__to_mem_waddr__en[5];
  assign to_mem_waddr__msg = element__to_mem_waddr__msg[5];
  assign element__to_mem_waddr__rdy[5] = to_mem_waddr__rdy;
  assign to_mem_wdata__en = element__to_mem_wdata__en[5];
  assign to_mem_wdata__msg = element__to_mem_wdata__msg[5];
  assign element__to_mem_wdata__rdy[5] = to_mem_wdata__rdy;
  assign crossbar__recv_data__en[0] = recv_data__en[0];
  assign crossbar__recv_data__msg[0] = recv_data__msg[0];
  assign recv_data__rdy[0] = crossbar__recv_data__rdy[0];
  assign crossbar__recv_data__en[1] = recv_data__en[1];
  assign crossbar__recv_data__msg[1] = recv_data__msg[1];
  assign recv_data__rdy[1] = crossbar__recv_data__rdy[1];
  assign crossbar__recv_data__en[2] = recv_data__en[2];
  assign crossbar__recv_data__msg[2] = recv_data__msg[2];
  assign recv_data__rdy[2] = crossbar__recv_data__rdy[2];
  assign crossbar__recv_data__en[3] = recv_data__en[3];
  assign crossbar__recv_data__msg[3] = recv_data__msg[3];
  assign recv_data__rdy[3] = crossbar__recv_data__rdy[3];
  assign crossbar__recv_data__en[4] = recv_data__en[4];
  assign crossbar__recv_data__msg[4] = recv_data__msg[4];
  assign recv_data__rdy[4] = crossbar__recv_data__rdy[4];
  assign crossbar__recv_data__en[5] = recv_data__en[5];
  assign crossbar__recv_data__msg[5] = recv_data__msg[5];
  assign recv_data__rdy[5] = crossbar__recv_data__rdy[5];
  assign crossbar__recv_data__en[6] = recv_data__en[6];
  assign crossbar__recv_data__msg[6] = recv_data__msg[6];
  assign recv_data__rdy[6] = crossbar__recv_data__rdy[6];
  assign crossbar__recv_data__en[7] = recv_data__en[7];
  assign crossbar__recv_data__msg[7] = recv_data__msg[7];
  assign recv_data__rdy[7] = crossbar__recv_data__rdy[7];
  assign channel__recv__en[0] = crossbar__send_data__en[0];
  assign channel__recv__msg[0] = crossbar__send_data__msg[0];
  assign crossbar__send_data__rdy[0] = channel__recv__rdy[0];
  assign channel__recv__en[1] = crossbar__send_data__en[1];
  assign channel__recv__msg[1] = crossbar__send_data__msg[1];
  assign crossbar__send_data__rdy[1] = channel__recv__rdy[1];
  assign channel__recv__en[2] = crossbar__send_data__en[2];
  assign channel__recv__msg[2] = crossbar__send_data__msg[2];
  assign crossbar__send_data__rdy[2] = channel__recv__rdy[2];
  assign channel__recv__en[3] = crossbar__send_data__en[3];
  assign channel__recv__msg[3] = crossbar__send_data__msg[3];
  assign crossbar__send_data__rdy[3] = channel__recv__rdy[3];
  assign channel__recv__en[4] = crossbar__send_data__en[4];
  assign channel__recv__msg[4] = crossbar__send_data__msg[4];
  assign crossbar__send_data__rdy[4] = channel__recv__rdy[4];
  assign channel__recv__en[5] = crossbar__send_data__en[5];
  assign channel__recv__msg[5] = crossbar__send_data__msg[5];
  assign crossbar__send_data__rdy[5] = channel__recv__rdy[5];
  assign channel__recv__en[6] = crossbar__send_data__en[6];
  assign channel__recv__msg[6] = crossbar__send_data__msg[6];
  assign crossbar__send_data__rdy[6] = channel__recv__rdy[6];
  assign channel__recv__en[7] = crossbar__send_data__en[7];
  assign channel__recv__msg[7] = crossbar__send_data__msg[7];
  assign crossbar__send_data__rdy[7] = channel__recv__rdy[7];
  assign channel__recv__en[8] = crossbar__send_data__en[8];
  assign channel__recv__msg[8] = crossbar__send_data__msg[8];
  assign crossbar__send_data__rdy[8] = channel__recv__rdy[8];
  assign channel__recv__en[9] = crossbar__send_data__en[9];
  assign channel__recv__msg[9] = crossbar__send_data__msg[9];
  assign crossbar__send_data__rdy[9] = channel__recv__rdy[9];
  assign channel__recv__en[10] = crossbar__send_data__en[10];
  assign channel__recv__msg[10] = crossbar__send_data__msg[10];
  assign crossbar__send_data__rdy[10] = channel__recv__rdy[10];
  assign channel__recv__en[11] = crossbar__send_data__en[11];
  assign channel__recv__msg[11] = crossbar__send_data__msg[11];
  assign crossbar__send_data__rdy[11] = channel__recv__rdy[11];
  assign reg_predicate__recv__en = crossbar__send_predicate__en;
  assign reg_predicate__recv__msg = crossbar__send_predicate__msg;
  assign crossbar__send_predicate__rdy = reg_predicate__recv__rdy;
  assign element__recv_predicate__en = reg_predicate__send__en;
  assign element__recv_predicate__msg = reg_predicate__send__msg;
  assign reg_predicate__send__rdy = element__recv_predicate__rdy;
  assign send_data__en[0] = channel__send__en[0];
  assign send_data__msg[0] = channel__send__msg[0];
  assign channel__send__rdy[0] = send_data__rdy[0];
  assign send_data__en[1] = channel__send__en[1];
  assign send_data__msg[1] = channel__send__msg[1];
  assign channel__send__rdy[1] = send_data__rdy[1];
  assign send_data__en[2] = channel__send__en[2];
  assign send_data__msg[2] = channel__send__msg[2];
  assign channel__send__rdy[2] = send_data__rdy[2];
  assign send_data__en[3] = channel__send__en[3];
  assign send_data__msg[3] = channel__send__msg[3];
  assign channel__send__rdy[3] = send_data__rdy[3];
  assign send_data__en[4] = channel__send__en[4];
  assign send_data__msg[4] = channel__send__msg[4];
  assign channel__send__rdy[4] = send_data__rdy[4];
  assign send_data__en[5] = channel__send__en[5];
  assign send_data__msg[5] = channel__send__msg[5];
  assign channel__send__rdy[5] = send_data__rdy[5];
  assign send_data__en[6] = channel__send__en[6];
  assign send_data__msg[6] = channel__send__msg[6];
  assign channel__send__rdy[6] = send_data__rdy[6];
  assign send_data__en[7] = channel__send__en[7];
  assign send_data__msg[7] = channel__send__msg[7];
  assign channel__send__rdy[7] = send_data__rdy[7];
  assign element__recv_in__en[0] = channel__send__en[8];
  assign element__recv_in__msg[0] = channel__send__msg[8];
  assign channel__send__rdy[8] = element__recv_in__rdy[0];
  assign element__recv_in_count[0] = channel__count[8];
  assign element__recv_in__en[1] = channel__send__en[9];
  assign element__recv_in__msg[1] = channel__send__msg[9];
  assign channel__send__rdy[9] = element__recv_in__rdy[1];
  assign element__recv_in_count[1] = channel__count[9];
  assign element__recv_in__en[2] = channel__send__en[10];
  assign element__recv_in__msg[2] = channel__send__msg[10];
  assign channel__send__rdy[10] = element__recv_in__rdy[2];
  assign element__recv_in_count[2] = channel__count[10];
  assign element__recv_in__en[3] = channel__send__en[11];
  assign element__recv_in__msg[3] = channel__send__msg[11];
  assign channel__send__rdy[11] = element__recv_in__rdy[3];
  assign element__recv_in_count[3] = channel__count[11];
  assign crossbar__recv_data__en[8] = element__send_out__en[0];
  assign crossbar__recv_data__msg[8] = element__send_out__msg[0];
  assign element__send_out__rdy[0] = crossbar__recv_data__rdy[8];
  assign crossbar__recv_data__en[9] = element__send_out__en[1];
  assign crossbar__recv_data__msg[9] = element__send_out__msg[1];
  assign element__send_out__rdy[1] = crossbar__recv_data__rdy[9];

endmodule


// PyMTL Component CGRAKingMeshRTL Definition
// Full name: CGRAKingMeshRTL__DataType_CGRAData_32_1_1__PredicateType_CGRAData_1_1__CtrlType_CGRAConfig_6_4_8_8__width_2__height_2__ctrl_mem_size_8__data_mem_size_8__num_ctrl_4__FunctionUnit_FlexibleFuRTL__FuList_[<class 'VectorCGRA.fu.single.PhiRTL.PhiRTL'>, <class 'VectorCGRA.fu.single.AdderRTL.AdderRTL'>, <class 'VectorCGRA.fu.single.ShifterRTL.ShifterRTL'>, <class 'VectorCGRA.fu.single.MemUnitRTL.MemUnitRTL'>, <class 'VectorCGRA.fu.single.SelRTL.SelRTL'>, <class 'VectorCGRA.fu.single.CompRTL.CompRTL'>, <class 'VectorCGRA.fu.double.SeqMulAdderRTL.SeqMulAdderRTL'>, <class 'VectorCGRA.fu.single.RetRTL.RetRTL'>, <class 'VectorCGRA.fu.single.MulRTL.MulRTL'>, <class 'VectorCGRA.fu.single.LogicRTL.LogicRTL'>, <class 'VectorCGRA.fu.single.BranchRTL.BranchRTL'>]__preload_data_None__preload_const_None
// At ../../VectorCGRA/cgra/CGRAKingMeshRTL.py

module CGRAKingMeshRTL__99cbcfeeb0999932
(
  input logic [0:0] clk,
  input logic [0:0] reset,
  input logic [0:0] recv_waddr__en [0:3],
  input logic [2:0] recv_waddr__msg [0:3],
  output logic [0:0] recv_waddr__rdy [0:3],
  input logic [0:0] recv_wopt__en [0:3],
  input CGRAConfig_6_4_8_8 recv_wopt__msg [0:3],
  output logic [0:0] recv_wopt__rdy [0:3]
);
  //-------------------------------------------------------------
  // Component data_mem
  //-------------------------------------------------------------

  logic [0:0] data_mem__clk ;
  logic [0:0] data_mem__reset ;
  logic [0:0] data_mem__recv_raddr__en [0:1] ;
  logic [2:0] data_mem__recv_raddr__msg [0:1] ;
  logic [0:0] data_mem__recv_raddr__rdy [0:1] ;
  logic [0:0] data_mem__recv_waddr__en [0:1] ;
  logic [2:0] data_mem__recv_waddr__msg [0:1] ;
  logic [0:0] data_mem__recv_waddr__rdy [0:1] ;
  logic [0:0] data_mem__recv_wdata__en [0:1] ;
  CGRAData_32_1_1 data_mem__recv_wdata__msg [0:1] ;
  logic [0:0] data_mem__recv_wdata__rdy [0:1] ;
  logic [0:0] data_mem__send_rdata__en [0:1] ;
  CGRAData_32_1_1 data_mem__send_rdata__msg [0:1] ;
  logic [0:0] data_mem__send_rdata__rdy [0:1] ;

  DataMemRTL__8bb42015d7ad3eea data_mem
  (
    .clk( data_mem__clk ),
    .reset( data_mem__reset ),
    .recv_raddr__en( data_mem__recv_raddr__en ),
    .recv_raddr__msg( data_mem__recv_raddr__msg ),
    .recv_raddr__rdy( data_mem__recv_raddr__rdy ),
    .recv_waddr__en( data_mem__recv_waddr__en ),
    .recv_waddr__msg( data_mem__recv_waddr__msg ),
    .recv_waddr__rdy( data_mem__recv_waddr__rdy ),
    .recv_wdata__en( data_mem__recv_wdata__en ),
    .recv_wdata__msg( data_mem__recv_wdata__msg ),
    .recv_wdata__rdy( data_mem__recv_wdata__rdy ),
    .send_rdata__en( data_mem__send_rdata__en ),
    .send_rdata__msg( data_mem__send_rdata__msg ),
    .send_rdata__rdy( data_mem__send_rdata__rdy )
  );

  //-------------------------------------------------------------
  // End of component data_mem
  //-------------------------------------------------------------

  //-------------------------------------------------------------
  // Component tile[0:3]
  //-------------------------------------------------------------

  logic [0:0] tile__clk [0:3] ;
  logic [0:0] tile__reset [0:3] ;
  logic [0:0] tile__from_mem_rdata__en [0:3] ;
  CGRAData_32_1_1 tile__from_mem_rdata__msg [0:3] ;
  logic [0:0] tile__from_mem_rdata__rdy [0:3] ;
  logic [0:0] tile__recv_data__en [0:3][0:7] ;
  CGRAData_32_1_1 tile__recv_data__msg [0:3][0:7] ;
  logic [0:0] tile__recv_data__rdy [0:3][0:7] ;
  logic [0:0] tile__recv_waddr__en [0:3] ;
  logic [2:0] tile__recv_waddr__msg [0:3] ;
  logic [0:0] tile__recv_waddr__rdy [0:3] ;
  logic [0:0] tile__recv_wopt__en [0:3] ;
  CGRAConfig_6_4_8_8 tile__recv_wopt__msg [0:3] ;
  logic [0:0] tile__recv_wopt__rdy [0:3] ;
  logic [0:0] tile__send_data__en [0:3][0:7] ;
  CGRAData_32_1_1 tile__send_data__msg [0:3][0:7] ;
  logic [0:0] tile__send_data__rdy [0:3][0:7] ;
  logic [0:0] tile__to_mem_raddr__en [0:3] ;
  logic [2:0] tile__to_mem_raddr__msg [0:3] ;
  logic [0:0] tile__to_mem_raddr__rdy [0:3] ;
  logic [0:0] tile__to_mem_waddr__en [0:3] ;
  logic [2:0] tile__to_mem_waddr__msg [0:3] ;
  logic [0:0] tile__to_mem_waddr__rdy [0:3] ;
  logic [0:0] tile__to_mem_wdata__en [0:3] ;
  CGRAData_32_1_1 tile__to_mem_wdata__msg [0:3] ;
  logic [0:0] tile__to_mem_wdata__rdy [0:3] ;

  TileRTL__40947ac956b390e0 tile__0
  (
    .clk( tile__clk[0] ),
    .reset( tile__reset[0] ),
    .from_mem_rdata__en( tile__from_mem_rdata__en[0] ),
    .from_mem_rdata__msg( tile__from_mem_rdata__msg[0] ),
    .from_mem_rdata__rdy( tile__from_mem_rdata__rdy[0] ),
    .recv_data__en( tile__recv_data__en[0] ),
    .recv_data__msg( tile__recv_data__msg[0] ),
    .recv_data__rdy( tile__recv_data__rdy[0] ),
    .recv_waddr__en( tile__recv_waddr__en[0] ),
    .recv_waddr__msg( tile__recv_waddr__msg[0] ),
    .recv_waddr__rdy( tile__recv_waddr__rdy[0] ),
    .recv_wopt__en( tile__recv_wopt__en[0] ),
    .recv_wopt__msg( tile__recv_wopt__msg[0] ),
    .recv_wopt__rdy( tile__recv_wopt__rdy[0] ),
    .send_data__en( tile__send_data__en[0] ),
    .send_data__msg( tile__send_data__msg[0] ),
    .send_data__rdy( tile__send_data__rdy[0] ),
    .to_mem_raddr__en( tile__to_mem_raddr__en[0] ),
    .to_mem_raddr__msg( tile__to_mem_raddr__msg[0] ),
    .to_mem_raddr__rdy( tile__to_mem_raddr__rdy[0] ),
    .to_mem_waddr__en( tile__to_mem_waddr__en[0] ),
    .to_mem_waddr__msg( tile__to_mem_waddr__msg[0] ),
    .to_mem_waddr__rdy( tile__to_mem_waddr__rdy[0] ),
    .to_mem_wdata__en( tile__to_mem_wdata__en[0] ),
    .to_mem_wdata__msg( tile__to_mem_wdata__msg[0] ),
    .to_mem_wdata__rdy( tile__to_mem_wdata__rdy[0] )
  );

  TileRTL__40947ac956b390e0 tile__1
  (
    .clk( tile__clk[1] ),
    .reset( tile__reset[1] ),
    .from_mem_rdata__en( tile__from_mem_rdata__en[1] ),
    .from_mem_rdata__msg( tile__from_mem_rdata__msg[1] ),
    .from_mem_rdata__rdy( tile__from_mem_rdata__rdy[1] ),
    .recv_data__en( tile__recv_data__en[1] ),
    .recv_data__msg( tile__recv_data__msg[1] ),
    .recv_data__rdy( tile__recv_data__rdy[1] ),
    .recv_waddr__en( tile__recv_waddr__en[1] ),
    .recv_waddr__msg( tile__recv_waddr__msg[1] ),
    .recv_waddr__rdy( tile__recv_waddr__rdy[1] ),
    .recv_wopt__en( tile__recv_wopt__en[1] ),
    .recv_wopt__msg( tile__recv_wopt__msg[1] ),
    .recv_wopt__rdy( tile__recv_wopt__rdy[1] ),
    .send_data__en( tile__send_data__en[1] ),
    .send_data__msg( tile__send_data__msg[1] ),
    .send_data__rdy( tile__send_data__rdy[1] ),
    .to_mem_raddr__en( tile__to_mem_raddr__en[1] ),
    .to_mem_raddr__msg( tile__to_mem_raddr__msg[1] ),
    .to_mem_raddr__rdy( tile__to_mem_raddr__rdy[1] ),
    .to_mem_waddr__en( tile__to_mem_waddr__en[1] ),
    .to_mem_waddr__msg( tile__to_mem_waddr__msg[1] ),
    .to_mem_waddr__rdy( tile__to_mem_waddr__rdy[1] ),
    .to_mem_wdata__en( tile__to_mem_wdata__en[1] ),
    .to_mem_wdata__msg( tile__to_mem_wdata__msg[1] ),
    .to_mem_wdata__rdy( tile__to_mem_wdata__rdy[1] )
  );

  TileRTL__40947ac956b390e0 tile__2
  (
    .clk( tile__clk[2] ),
    .reset( tile__reset[2] ),
    .from_mem_rdata__en( tile__from_mem_rdata__en[2] ),
    .from_mem_rdata__msg( tile__from_mem_rdata__msg[2] ),
    .from_mem_rdata__rdy( tile__from_mem_rdata__rdy[2] ),
    .recv_data__en( tile__recv_data__en[2] ),
    .recv_data__msg( tile__recv_data__msg[2] ),
    .recv_data__rdy( tile__recv_data__rdy[2] ),
    .recv_waddr__en( tile__recv_waddr__en[2] ),
    .recv_waddr__msg( tile__recv_waddr__msg[2] ),
    .recv_waddr__rdy( tile__recv_waddr__rdy[2] ),
    .recv_wopt__en( tile__recv_wopt__en[2] ),
    .recv_wopt__msg( tile__recv_wopt__msg[2] ),
    .recv_wopt__rdy( tile__recv_wopt__rdy[2] ),
    .send_data__en( tile__send_data__en[2] ),
    .send_data__msg( tile__send_data__msg[2] ),
    .send_data__rdy( tile__send_data__rdy[2] ),
    .to_mem_raddr__en( tile__to_mem_raddr__en[2] ),
    .to_mem_raddr__msg( tile__to_mem_raddr__msg[2] ),
    .to_mem_raddr__rdy( tile__to_mem_raddr__rdy[2] ),
    .to_mem_waddr__en( tile__to_mem_waddr__en[2] ),
    .to_mem_waddr__msg( tile__to_mem_waddr__msg[2] ),
    .to_mem_waddr__rdy( tile__to_mem_waddr__rdy[2] ),
    .to_mem_wdata__en( tile__to_mem_wdata__en[2] ),
    .to_mem_wdata__msg( tile__to_mem_wdata__msg[2] ),
    .to_mem_wdata__rdy( tile__to_mem_wdata__rdy[2] )
  );

  TileRTL__40947ac956b390e0 tile__3
  (
    .clk( tile__clk[3] ),
    .reset( tile__reset[3] ),
    .from_mem_rdata__en( tile__from_mem_rdata__en[3] ),
    .from_mem_rdata__msg( tile__from_mem_rdata__msg[3] ),
    .from_mem_rdata__rdy( tile__from_mem_rdata__rdy[3] ),
    .recv_data__en( tile__recv_data__en[3] ),
    .recv_data__msg( tile__recv_data__msg[3] ),
    .recv_data__rdy( tile__recv_data__rdy[3] ),
    .recv_waddr__en( tile__recv_waddr__en[3] ),
    .recv_waddr__msg( tile__recv_waddr__msg[3] ),
    .recv_waddr__rdy( tile__recv_waddr__rdy[3] ),
    .recv_wopt__en( tile__recv_wopt__en[3] ),
    .recv_wopt__msg( tile__recv_wopt__msg[3] ),
    .recv_wopt__rdy( tile__recv_wopt__rdy[3] ),
    .send_data__en( tile__send_data__en[3] ),
    .send_data__msg( tile__send_data__msg[3] ),
    .send_data__rdy( tile__send_data__rdy[3] ),
    .to_mem_raddr__en( tile__to_mem_raddr__en[3] ),
    .to_mem_raddr__msg( tile__to_mem_raddr__msg[3] ),
    .to_mem_raddr__rdy( tile__to_mem_raddr__rdy[3] ),
    .to_mem_waddr__en( tile__to_mem_waddr__en[3] ),
    .to_mem_waddr__msg( tile__to_mem_waddr__msg[3] ),
    .to_mem_waddr__rdy( tile__to_mem_waddr__rdy[3] ),
    .to_mem_wdata__en( tile__to_mem_wdata__en[3] ),
    .to_mem_wdata__msg( tile__to_mem_wdata__msg[3] ),
    .to_mem_wdata__rdy( tile__to_mem_wdata__rdy[3] )
  );

  //-------------------------------------------------------------
  // End of component tile[0:3]
  //-------------------------------------------------------------

  assign tile__clk[0] = clk;
  assign tile__reset[0] = reset;
  assign tile__clk[1] = clk;
  assign tile__reset[1] = reset;
  assign tile__clk[2] = clk;
  assign tile__reset[2] = reset;
  assign tile__clk[3] = clk;
  assign tile__reset[3] = reset;
  assign data_mem__clk = clk;
  assign data_mem__reset = reset;
  assign tile__recv_waddr__en[0] = recv_waddr__en[0];
  assign tile__recv_waddr__msg[0] = recv_waddr__msg[0];
  assign recv_waddr__rdy[0] = tile__recv_waddr__rdy[0];
  assign tile__recv_wopt__en[0] = recv_wopt__en[0];
  assign tile__recv_wopt__msg[0] = recv_wopt__msg[0];
  assign recv_wopt__rdy[0] = tile__recv_wopt__rdy[0];
  assign tile__recv_data__en[2][1] = tile__send_data__en[0][0];
  assign tile__recv_data__msg[2][1] = tile__send_data__msg[0][0];
  assign tile__send_data__rdy[0][0] = tile__recv_data__rdy[2][1];
  assign tile__recv_data__en[1][2] = tile__send_data__en[0][3];
  assign tile__recv_data__msg[1][2] = tile__send_data__msg[0][3];
  assign tile__send_data__rdy[0][3] = tile__recv_data__rdy[1][2];
  assign tile__recv_data__en[3][7] = tile__send_data__en[0][5];
  assign tile__recv_data__msg[3][7] = tile__send_data__msg[0][5];
  assign tile__send_data__rdy[0][5] = tile__recv_data__rdy[3][7];
  assign tile__recv_data__en[0][5] = tile__send_data__en[3][7];
  assign tile__recv_data__msg[0][5] = tile__send_data__msg[3][7];
  assign tile__send_data__rdy[3][7] = tile__recv_data__rdy[0][5];
  assign tile__send_data__rdy[0][1] = 1'd0;
  assign tile__recv_data__en[0][1] = 1'd0;
  assign tile__recv_data__msg[0][1] = { 32'd0, 1'd0, 1'd0 };
  assign tile__send_data__rdy[0][7] = 1'd0;
  assign tile__recv_data__en[0][7] = 1'd0;
  assign tile__recv_data__msg[0][7] = { 32'd0, 1'd0, 1'd0 };
  assign tile__send_data__rdy[0][6] = 1'd0;
  assign tile__recv_data__en[0][6] = 1'd0;
  assign tile__recv_data__msg[0][6] = { 32'd0, 1'd0, 1'd0 };
  assign tile__send_data__rdy[0][4] = 1'd0;
  assign tile__recv_data__en[0][4] = 1'd0;
  assign tile__recv_data__msg[0][4] = { 32'd0, 1'd0, 1'd0 };
  assign tile__send_data__rdy[0][2] = 1'd0;
  assign tile__recv_data__en[0][2] = 1'd0;
  assign tile__recv_data__msg[0][2] = { 32'd0, 1'd0, 1'd0 };
  assign data_mem__recv_raddr__en[0] = tile__to_mem_raddr__en[0];
  assign data_mem__recv_raddr__msg[0] = tile__to_mem_raddr__msg[0];
  assign tile__to_mem_raddr__rdy[0] = data_mem__recv_raddr__rdy[0];
  assign tile__from_mem_rdata__en[0] = data_mem__send_rdata__en[0];
  assign tile__from_mem_rdata__msg[0] = data_mem__send_rdata__msg[0];
  assign data_mem__send_rdata__rdy[0] = tile__from_mem_rdata__rdy[0];
  assign data_mem__recv_waddr__en[0] = tile__to_mem_waddr__en[0];
  assign data_mem__recv_waddr__msg[0] = tile__to_mem_waddr__msg[0];
  assign tile__to_mem_waddr__rdy[0] = data_mem__recv_waddr__rdy[0];
  assign data_mem__recv_wdata__en[0] = tile__to_mem_wdata__en[0];
  assign data_mem__recv_wdata__msg[0] = tile__to_mem_wdata__msg[0];
  assign tile__to_mem_wdata__rdy[0] = data_mem__recv_wdata__rdy[0];
  assign tile__recv_waddr__en[1] = recv_waddr__en[1];
  assign tile__recv_waddr__msg[1] = recv_waddr__msg[1];
  assign recv_waddr__rdy[1] = tile__recv_waddr__rdy[1];
  assign tile__recv_wopt__en[1] = recv_wopt__en[1];
  assign tile__recv_wopt__msg[1] = recv_wopt__msg[1];
  assign recv_wopt__rdy[1] = tile__recv_wopt__rdy[1];
  assign tile__recv_data__en[3][1] = tile__send_data__en[1][0];
  assign tile__recv_data__msg[3][1] = tile__send_data__msg[1][0];
  assign tile__send_data__rdy[1][0] = tile__recv_data__rdy[3][1];
  assign tile__recv_data__en[0][3] = tile__send_data__en[1][2];
  assign tile__recv_data__msg[0][3] = tile__send_data__msg[1][2];
  assign tile__send_data__rdy[1][2] = tile__recv_data__rdy[0][3];
  assign tile__recv_data__en[2][6] = tile__send_data__en[1][4];
  assign tile__recv_data__msg[2][6] = tile__send_data__msg[1][4];
  assign tile__send_data__rdy[1][4] = tile__recv_data__rdy[2][6];
  assign tile__recv_data__en[1][4] = tile__send_data__en[2][6];
  assign tile__recv_data__msg[1][4] = tile__send_data__msg[2][6];
  assign tile__send_data__rdy[2][6] = tile__recv_data__rdy[1][4];
  assign tile__send_data__rdy[1][1] = 1'd0;
  assign tile__recv_data__en[1][1] = 1'd0;
  assign tile__recv_data__msg[1][1] = { 32'd0, 1'd0, 1'd0 };
  assign tile__send_data__rdy[1][7] = 1'd0;
  assign tile__recv_data__en[1][7] = 1'd0;
  assign tile__recv_data__msg[1][7] = { 32'd0, 1'd0, 1'd0 };
  assign tile__send_data__rdy[1][6] = 1'd0;
  assign tile__recv_data__en[1][6] = 1'd0;
  assign tile__recv_data__msg[1][6] = { 32'd0, 1'd0, 1'd0 };
  assign tile__send_data__rdy[1][5] = 1'd0;
  assign tile__recv_data__en[1][5] = 1'd0;
  assign tile__recv_data__msg[1][5] = { 32'd0, 1'd0, 1'd0 };
  assign tile__send_data__rdy[1][3] = 1'd0;
  assign tile__recv_data__en[1][3] = 1'd0;
  assign tile__recv_data__msg[1][3] = { 32'd0, 1'd0, 1'd0 };
  assign tile__to_mem_raddr__rdy[1] = 1'd0;
  assign tile__from_mem_rdata__en[1] = 1'd0;
  assign tile__from_mem_rdata__msg[1] = { 32'd0, 1'd0, 1'd0 };
  assign tile__to_mem_waddr__rdy[1] = 1'd0;
  assign tile__to_mem_wdata__rdy[1] = 1'd0;
  assign tile__recv_waddr__en[2] = recv_waddr__en[2];
  assign tile__recv_waddr__msg[2] = recv_waddr__msg[2];
  assign recv_waddr__rdy[2] = tile__recv_waddr__rdy[2];
  assign tile__recv_wopt__en[2] = recv_wopt__en[2];
  assign tile__recv_wopt__msg[2] = recv_wopt__msg[2];
  assign recv_wopt__rdy[2] = tile__recv_wopt__rdy[2];
  assign tile__recv_data__en[0][0] = tile__send_data__en[2][1];
  assign tile__recv_data__msg[0][0] = tile__send_data__msg[2][1];
  assign tile__send_data__rdy[2][1] = tile__recv_data__rdy[0][0];
  assign tile__recv_data__en[3][2] = tile__send_data__en[2][3];
  assign tile__recv_data__msg[3][2] = tile__send_data__msg[2][3];
  assign tile__send_data__rdy[2][3] = tile__recv_data__rdy[3][2];
  assign tile__send_data__rdy[2][0] = 1'd0;
  assign tile__recv_data__en[2][0] = 1'd0;
  assign tile__recv_data__msg[2][0] = { 32'd0, 1'd0, 1'd0 };
  assign tile__send_data__rdy[2][4] = 1'd0;
  assign tile__recv_data__en[2][4] = 1'd0;
  assign tile__recv_data__msg[2][4] = { 32'd0, 1'd0, 1'd0 };
  assign tile__send_data__rdy[2][5] = 1'd0;
  assign tile__recv_data__en[2][5] = 1'd0;
  assign tile__recv_data__msg[2][5] = { 32'd0, 1'd0, 1'd0 };
  assign tile__send_data__rdy[2][7] = 1'd0;
  assign tile__recv_data__en[2][7] = 1'd0;
  assign tile__recv_data__msg[2][7] = { 32'd0, 1'd0, 1'd0 };
  assign tile__send_data__rdy[2][2] = 1'd0;
  assign tile__recv_data__en[2][2] = 1'd0;
  assign tile__recv_data__msg[2][2] = { 32'd0, 1'd0, 1'd0 };
  assign data_mem__recv_raddr__en[1] = tile__to_mem_raddr__en[2];
  assign data_mem__recv_raddr__msg[1] = tile__to_mem_raddr__msg[2];
  assign tile__to_mem_raddr__rdy[2] = data_mem__recv_raddr__rdy[1];
  assign tile__from_mem_rdata__en[2] = data_mem__send_rdata__en[1];
  assign tile__from_mem_rdata__msg[2] = data_mem__send_rdata__msg[1];
  assign data_mem__send_rdata__rdy[1] = tile__from_mem_rdata__rdy[2];
  assign data_mem__recv_waddr__en[1] = tile__to_mem_waddr__en[2];
  assign data_mem__recv_waddr__msg[1] = tile__to_mem_waddr__msg[2];
  assign tile__to_mem_waddr__rdy[2] = data_mem__recv_waddr__rdy[1];
  assign data_mem__recv_wdata__en[1] = tile__to_mem_wdata__en[2];
  assign data_mem__recv_wdata__msg[1] = tile__to_mem_wdata__msg[2];
  assign tile__to_mem_wdata__rdy[2] = data_mem__recv_wdata__rdy[1];
  assign tile__recv_waddr__en[3] = recv_waddr__en[3];
  assign tile__recv_waddr__msg[3] = recv_waddr__msg[3];
  assign recv_waddr__rdy[3] = tile__recv_waddr__rdy[3];
  assign tile__recv_wopt__en[3] = recv_wopt__en[3];
  assign tile__recv_wopt__msg[3] = recv_wopt__msg[3];
  assign recv_wopt__rdy[3] = tile__recv_wopt__rdy[3];
  assign tile__recv_data__en[1][0] = tile__send_data__en[3][1];
  assign tile__recv_data__msg[1][0] = tile__send_data__msg[3][1];
  assign tile__send_data__rdy[3][1] = tile__recv_data__rdy[1][0];
  assign tile__recv_data__en[2][3] = tile__send_data__en[3][2];
  assign tile__recv_data__msg[2][3] = tile__send_data__msg[3][2];
  assign tile__send_data__rdy[3][2] = tile__recv_data__rdy[2][3];
  assign tile__send_data__rdy[3][0] = 1'd0;
  assign tile__recv_data__en[3][0] = 1'd0;
  assign tile__recv_data__msg[3][0] = { 32'd0, 1'd0, 1'd0 };
  assign tile__send_data__rdy[3][4] = 1'd0;
  assign tile__recv_data__en[3][4] = 1'd0;
  assign tile__recv_data__msg[3][4] = { 32'd0, 1'd0, 1'd0 };
  assign tile__send_data__rdy[3][5] = 1'd0;
  assign tile__recv_data__en[3][5] = 1'd0;
  assign tile__recv_data__msg[3][5] = { 32'd0, 1'd0, 1'd0 };
  assign tile__send_data__rdy[3][6] = 1'd0;
  assign tile__recv_data__en[3][6] = 1'd0;
  assign tile__recv_data__msg[3][6] = { 32'd0, 1'd0, 1'd0 };
  assign tile__send_data__rdy[3][3] = 1'd0;
  assign tile__recv_data__en[3][3] = 1'd0;
  assign tile__recv_data__msg[3][3] = { 32'd0, 1'd0, 1'd0 };
  assign tile__to_mem_raddr__rdy[3] = 1'd0;
  assign tile__from_mem_rdata__en[3] = 1'd0;
  assign tile__from_mem_rdata__msg[3] = { 32'd0, 1'd0, 1'd0 };
  assign tile__to_mem_waddr__rdy[3] = 1'd0;
  assign tile__to_mem_wdata__rdy[3] = 1'd0;

endmodule
